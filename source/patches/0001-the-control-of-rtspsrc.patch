From f77fae1c254bf1e26597dcbaf1a382420e5931f4 Mon Sep 17 00:00:00 2001
From: yc yang <ycyang@amazon.com>
Date: Mon, 12 Jul 2021 14:53:01 +0800
Subject: [PATCH] the-control-of-rtspsrc

---
 .../libkvsCommonLws-CMakeLists.txt            |   9 +-
 .../libkvsCommonLws-ecs-support.patch         | 709 ++++++++++++++
 samples/CMakeLists.txt                        |  13 +-
 samples/Common.c                              | 102 +-
 samples/Samples.h                             |  75 +-
 samples/kvsWebRTCClientMaster.c               |  11 +-
 samples/kvsWebRTCClientMasterGstRtspSample.c  | 922 ++++++++++++++++++
 .../kvsWebRTCClientMasterGstreamerSample.c    |   5 -
 samples/kvsWebRTCClientViewer.c               |   7 +-
 scripts/generate-iot-credential.sh            |  47 +-
 src/source/Signaling/LwsApiCalls.c            |  54 +-
 11 files changed, 1862 insertions(+), 92 deletions(-)
 create mode 100644 CMake/Dependencies/libkvsCommonLws-ecs-support.patch
 create mode 100644 samples/kvsWebRTCClientMasterGstRtspSample.c

diff --git a/CMake/Dependencies/libkvsCommonLws-CMakeLists.txt b/CMake/Dependencies/libkvsCommonLws-CMakeLists.txt
index 2420be89b..8db195b1a 100644
--- a/CMake/Dependencies/libkvsCommonLws-CMakeLists.txt
+++ b/CMake/Dependencies/libkvsCommonLws-CMakeLists.txt
@@ -2,11 +2,18 @@ cmake_minimum_required(VERSION 2.8)
 
 project(libkvsCommonLws-download NONE)
 
+SET(PATCH_COMMAND "")
+
+if (NOT WIN32)
+    set(PATCH_COMMAND ${PATCH_COMMAND} git apply --ignore-whitespace ${CMAKE_CURRENT_LIST_DIR}/libkvsCommonLws-ecs-support.patch)
+endif()
+
 include(ExternalProject)
 
 ExternalProject_Add(libkvsCommonLws-download
     GIT_REPOSITORY    https://github.com/awslabs/amazon-kinesis-video-streams-producer-c.git
-    GIT_TAG           d1095356712729d0489e56d1d0e27f5ce0a29fad
+    GIT_TAG           a8091d1a140fbdcb260ba3c8302aa2e4712d2d91
+    PATCH_COMMAND     ${PATCH_COMMAND}
     PREFIX            ${CMAKE_CURRENT_BINARY_DIR}/build
     CMAKE_ARGS        
       -DCMAKE_INSTALL_PREFIX=${OPEN_SRC_INSTALL_PREFIX}
diff --git a/CMake/Dependencies/libkvsCommonLws-ecs-support.patch b/CMake/Dependencies/libkvsCommonLws-ecs-support.patch
new file mode 100644
index 000000000..b3a39242f
--- /dev/null
+++ b/CMake/Dependencies/libkvsCommonLws-ecs-support.patch
@@ -0,0 +1,709 @@
+From 6725290bf69ff797aebeecf3f99ae9dba89283e8 Mon Sep 17 00:00:00 2001
+From: yc yang <ycyang@amazon.com>
+Date: Thu, 8 Jul 2021 22:17:24 +0800
+Subject: [PATCH] ecs-support-patch
+
+---
+ .../amazonaws/kinesis/video/common/Include.h  |  54 +++-
+ src/source/Common/EcsCredentialProvider.c     | 293 ++++++++++++++++++
+ src/source/Common/EcsCredentialProvider.h     |  64 ++++
+ src/source/Common/Include_i.h                 |   2 +
+ src/source/Common/IotCredentialProvider.c     |   2 +-
+ src/source/Common/Lws/LwsCall.c               |  86 ++++-
+ src/source/Common/Lws/LwsCall.h               |   1 +
+ .../Common/Lws/LwsEcsCredentialProvider.c     |  16 +
+ .../Common/Lws/LwsEcsCredentialProvider.h     |  16 +
+ src/source/Common/RequestInfo.c               |   3 +-
+ 10 files changed, 533 insertions(+), 4 deletions(-)
+ create mode 100644 src/source/Common/EcsCredentialProvider.c
+ create mode 100644 src/source/Common/EcsCredentialProvider.h
+ create mode 100644 src/source/Common/Lws/LwsEcsCredentialProvider.c
+ create mode 100644 src/source/Common/Lws/LwsEcsCredentialProvider.h
+
+diff --git a/src/include/com/amazonaws/kinesis/video/common/Include.h b/src/include/com/amazonaws/kinesis/video/common/Include.h
+index 17080ca..b34256e 100644
+--- a/src/include/com/amazonaws/kinesis/video/common/Include.h
++++ b/src/include/com/amazonaws/kinesis/video/common/Include.h
+@@ -50,6 +50,11 @@ extern "C" {
+ #define STATUS_FILE_CREDENTIAL_PROVIDER_OPEN_FILE_FAILED    STATUS_COMMON_PRODUCER_BASE + 0x00000022
+ #define STATUS_FILE_CREDENTIAL_PROVIDER_INVALID_FILE_LENGTH STATUS_COMMON_PRODUCER_BASE + 0x00000023
+ #define STATUS_FILE_CREDENTIAL_PROVIDER_INVALID_FILE_FORMAT STATUS_COMMON_PRODUCER_BASE + 0x00000024
++#define STATUS_ECS_AUTH_URI_FAILED                          STATUS_COMMON_PRODUCER_BASE + 0x00000025
++#define STATUS_ECS_AUTH_FAILED                              STATUS_COMMON_PRODUCER_BASE + 0x00000026
++#define STATUS_ECS_AUTH_RSP_FAILED                          STATUS_COMMON_PRODUCER_BASE + 0x00000027
++#define STATUS_MAX_ECS_TOKEN_LENGTH                         STATUS_COMMON_PRODUCER_BASE + 0x00000028
++#define STATUS_ECS_URI_LENGTH                               STATUS_COMMON_PRODUCER_BASE + 0x00000029
+ /*!@} */
+ 
+ /**
+@@ -137,6 +142,11 @@ extern "C" {
+  */
+ #define MAX_IOT_THING_NAME_LEN MAX_STREAM_NAME_LEN
+ 
++/**
++ * Maximum allowed string length for ECS authorization token
++ */
++#define MAX_ECS_TOKEN_LEN 2048
++
+ /**
+  * Maximum allowed request header length
+  */
+@@ -259,6 +269,7 @@ extern "C" {
+  * HTTPS Protocol scheme name
+  */
+ #define HTTPS_SCHEME_NAME "https"
++#define HTTP_SCHEME_NAME  "http"
+ 
+ /**
+  * WSS Protocol scheme name
+@@ -283,6 +294,11 @@ extern "C" {
+  */
+ #define SCHEMA_DELIMITER_STRING (PCHAR) "://"
+ 
++/**
++ *  Port delimiter string
++ */
++#define PORT_DELIMITER_STRING ":"
++
+ /**
+  * Default canonical URI if we fail to get anything from the parsing
+  */
+@@ -471,6 +487,7 @@ struct __RequestInfo {
+                                               //!< NOTE: In streaming mode the body will be NULL
+                                               //!< NOTE: The body will follow the main struct
+     UINT32 bodySize;                          //!< Size of the body in bytes
++    UINT32 port;                              //!< Port number of the request.
+     CHAR url[MAX_URI_CHAR_LEN + 1];           //!< The URL for the request
+     CHAR certPath[MAX_PATH_LEN + 1];          //!< CA Certificate path to use - optional
+     CHAR sslCertPath[MAX_PATH_LEN + 1];       //!< SSL Certificate file path to use - optional
+@@ -669,6 +686,41 @@ PUBLIC_API STATUS createLwsIotCredentialProviderWithTime(PCHAR, PCHAR, PCHAR, PC
+  */
+ PUBLIC_API STATUS freeIotCredentialProvider(PAwsCredentialProvider*);
+ 
++/**
++ * @brief Creates an ECS based AWS credential provider object using libWebSockets
++ *        https://docs.aws.amazon.com/greengrass/v2/developerguide/token-exchange-service-component.html
++ *        https://docs.aws.amazon.com/greengrass/v2/developerguide/component-environment-variables.html
++ *
++ * @param[in] PCHAR Full uri of ECS credentials which is retrieved from the environment variable(AWS_CONTAINER_CREDENTIALS_FULL_URI)
++ * @param[in] PCHAR Authorization token of ECS credentials which is retrieved from the environment variable(AWS_CONTAINER_AUTHORIZATION_TOKEN)
++ * @param[out] PAwsCredentialProvider* Constructed AWS credentials provider object
++ *
++ * @return STATUS code of the execution. STATUS_SUCCESS on success
++ */
++PUBLIC_API STATUS createLwsEcsCredentialProvider(PCHAR, PCHAR, PAwsCredentialProvider*);
++
++/**
++ * @brief Creates an ECS based AWS credential provider object with time function which is based on libCurl
++ *
++ * @param[in] PCHAR Full uri of ECS credentials which is retrieved from the environment variable(AWS_CONTAINER_CREDENTIALS_FULL_URI)
++ * @param[in] PCHAR Authorization token of ECS credentials which is retrieved from the environment variable(AWS_CONTAINER_AUTHORIZATION_TOKEN)
++ * @param[in] GetCurrentTimeFunc Custom current time function
++ * @param[in] UINT64 Time function custom data
++ * @param[out] PAwsCredentialProvider* Constructed AWS credentials provider object
++ *
++ * @return STATUS code of the execution. STATUS_SUCCESS on success
++ */
++PUBLIC_API STATUS createLwsEcsCredentialProviderWithTime(PCHAR, PCHAR, GetCurrentTimeFunc, UINT64, PAwsCredentialProvider*);
++
++/**
++ * @brief Frees an ECS based Aws credential provider object
++ *
++ * @param[in,out] PAwsCredentialProvider* Object to be destroyed.
++ *
++ * @return STATUS code of the execution. STATUS_SUCCESS on success
++ */
++PUBLIC_API STATUS freeEcsCredentialProvider(PAwsCredentialProvider*);
++
+ /**
+  * @brief Creates a File based AWS credential provider object
+  *
+@@ -720,7 +772,7 @@ PUBLIC_API STATUS freeFileCredentialProvider(PAwsCredentialProvider*);
+  *
+  * @return STATUS code of the execution. STATUS_SUCCESS on success
+  */
+-PUBLIC_API STATUS createRequestInfo(PCHAR, PCHAR, PCHAR, PCHAR, PCHAR, PCHAR, SSL_CERTIFICATE_TYPE, PCHAR, UINT64, UINT64, UINT64, UINT64,
++PUBLIC_API STATUS createRequestInfo(PCHAR, PCHAR, UINT32, PCHAR, PCHAR, PCHAR, PCHAR, SSL_CERTIFICATE_TYPE, PCHAR, UINT64, UINT64, UINT64, UINT64,
+                                     PAwsCredentials, PRequestInfo*);
+ 
+ /**
+diff --git a/src/source/Common/EcsCredentialProvider.c b/src/source/Common/EcsCredentialProvider.c
+new file mode 100644
+index 0000000..7af931f
+--- /dev/null
++++ b/src/source/Common/EcsCredentialProvider.c
+@@ -0,0 +1,293 @@
++/**
++ * Kinesis Video Producer ECS based Credential Provider
++ */
++#define LOG_CLASS "EcsCredentialProvider"
++#include "Include_i.h"
++
++STATUS createEcsCredentialProviderWithTime(PCHAR ecsCredentialFullUri, PCHAR token, GetCurrentTimeFunc getCurrentTimeFn, UINT64 customData,
++                                           BlockingServiceCallFunc serviceCallFn, PAwsCredentialProvider* ppCredentialProvider)
++{
++    ENTERS();
++    STATUS retStatus = STATUS_SUCCESS;
++    PEcsCredentialProvider pEcsCredentialProvider = NULL;
++    PCHAR pStart, pEnd;
++    UINT32 len;
++    UINT32 port = 0;
++    UINT32 fullUriLen = 0;
++
++    CHK(ppCredentialProvider != NULL && ecsCredentialFullUri != NULL && token != NULL && serviceCallFn != NULL, STATUS_NULL_ARG);
++
++    pEcsCredentialProvider = (PEcsCredentialProvider) MEMCALLOC(1, SIZEOF(EcsCredentialProvider));
++    CHK(pEcsCredentialProvider != NULL, STATUS_NOT_ENOUGH_MEMORY);
++
++    pEcsCredentialProvider->credentialProvider.getCredentialsFn = getEcsCredentials;
++
++    // Store the time functionality and specify default if NULL
++    pEcsCredentialProvider->getCurrentTimeFn = (getCurrentTimeFn == NULL) ? commonDefaultGetCurrentTimeFunc : getCurrentTimeFn;
++    pEcsCredentialProvider->customData = customData;
++
++    fullUriLen = STRNLEN(ecsCredentialFullUri, MAX_URI_CHAR_LEN + 1);
++
++    CHK(fullUriLen <= MAX_URI_CHAR_LEN, STATUS_ECS_URI_LENGTH);
++    CHK_STATUS(getRequestHost(ecsCredentialFullUri, &pStart, &pEnd));
++    len = (UINT32) (pEnd - ecsCredentialFullUri);
++    STRNCPY(pEcsCredentialProvider->ecsGetCredentialEndpoint, ecsCredentialFullUri, len);
++    pEcsCredentialProvider->ecsGetCredentialEndpoint[len] = '\0';
++
++    CHK_STATUS(getHostPort(ecsCredentialFullUri + len, &pStart, &pEnd));
++    CHK_STATUS(STRTOUI32(pStart, pEnd, 10, &port));
++    pEcsCredentialProvider->port = port;
++    len = (ecsCredentialFullUri + fullUriLen) - pEnd;
++    STRNCPY(pEcsCredentialProvider->ecsGetCredentialResource, pEnd + 1, len);
++
++    CHK(STRNLEN(token, MAX_ECS_TOKEN_LEN + 1) <= MAX_ECS_TOKEN_LEN, STATUS_MAX_ECS_TOKEN_LENGTH);
++    STRNCPY(pEcsCredentialProvider->token, token, MAX_ECS_TOKEN_LEN);
++
++    pEcsCredentialProvider->serviceCallFn = serviceCallFn;
++
++    CHK_STATUS(ecsCurlHandler(pEcsCredentialProvider));
++
++CleanUp:
++
++    if (STATUS_FAILED(retStatus)) {
++        freeEcsCredentialProvider((PAwsCredentialProvider*) &pEcsCredentialProvider);
++        pEcsCredentialProvider = NULL;
++    }
++
++    // Set the return value if it's not NULL
++    if (ppCredentialProvider != NULL) {
++        *ppCredentialProvider = (PAwsCredentialProvider) pEcsCredentialProvider;
++    }
++
++    LEAVES();
++    return retStatus;
++}
++
++STATUS freeEcsCredentialProvider(PAwsCredentialProvider* ppCredentialProvider)
++{
++    ENTERS();
++    STATUS retStatus = STATUS_SUCCESS;
++    PEcsCredentialProvider pEcsCredentialProvider = NULL;
++
++    CHK(ppCredentialProvider != NULL, STATUS_NULL_ARG);
++
++    pEcsCredentialProvider = (PEcsCredentialProvider) *ppCredentialProvider;
++
++    // Call is idempotent
++    CHK(pEcsCredentialProvider != NULL, retStatus);
++
++    // Release the underlying AWS credentials object
++    freeAwsCredentials(&pEcsCredentialProvider->pAwsCredentials);
++
++    // Release the object
++    MEMFREE(pEcsCredentialProvider);
++
++    // Set the pointer to NULL
++    *ppCredentialProvider = NULL;
++
++CleanUp:
++
++    LEAVES();
++    return retStatus;
++}
++
++STATUS getEcsCredentials(PAwsCredentialProvider pCredentialProvider, PAwsCredentials* ppAwsCredentials)
++{
++    ENTERS();
++
++    STATUS retStatus = STATUS_SUCCESS;
++
++    PEcsCredentialProvider pEcsCredentialProvider = (PEcsCredentialProvider) pCredentialProvider;
++
++    CHK(pEcsCredentialProvider != NULL && ppAwsCredentials != NULL, STATUS_NULL_ARG);
++
++    // Fill the credentials
++    CHK_STATUS(ecsCurlHandler(pEcsCredentialProvider));
++
++    *ppAwsCredentials = pEcsCredentialProvider->pAwsCredentials;
++
++CleanUp:
++
++    LEAVES();
++    return retStatus;
++}
++
++STATUS parseEcsResponse(PEcsCredentialProvider pEcsCredentialProvider, PCallInfo pCallInfo)
++{
++    ENTERS();
++    STATUS retStatus = STATUS_SUCCESS;
++
++    UINT32 i, resultLen, accessKeyIdLen = 0, secretKeyLen = 0, sessionTokenLen = 0, expirationTimestampLen = 0;
++    INT32 tokenCount;
++    jsmn_parser parser;
++    jsmntok_t tokens[MAX_JSON_TOKEN_COUNT];
++    PCHAR accessKeyId = NULL, secretKey = NULL, sessionToken = NULL, expirationTimestamp = NULL, pResponseStr = NULL;
++    UINT64 expiration, currentTime;
++    CHAR expirationTimestampStr[MAX_EXPIRATION_LEN + 1];
++
++    CHK(pEcsCredentialProvider != NULL && pCallInfo != NULL, STATUS_NULL_ARG);
++
++    resultLen = pCallInfo->responseDataLen;
++    pResponseStr = pCallInfo->responseData;
++    CHK(resultLen > 0, STATUS_ECS_AUTH_FAILED);
++
++    jsmn_init(&parser);
++    tokenCount = jsmn_parse(&parser, pResponseStr, resultLen, tokens, SIZEOF(tokens) / SIZEOF(jsmntok_t));
++
++    CHK(tokenCount > 1, STATUS_INVALID_API_CALL_RETURN_JSON);
++    CHK(tokens[0].type == JSMN_OBJECT, STATUS_INVALID_API_CALL_RETURN_JSON);
++
++    for (i = 1; i < (UINT32) tokenCount; i++) {
++        if (compareJsonString(pResponseStr, &tokens[i], JSMN_STRING, (PCHAR) "AccessKeyId")) {
++            accessKeyIdLen = (UINT32) (tokens[i + 1].end - tokens[i + 1].start);
++            CHK(accessKeyIdLen <= MAX_ACCESS_KEY_LEN, STATUS_INVALID_API_CALL_RETURN_JSON);
++            accessKeyId = pResponseStr + tokens[i + 1].start;
++            i++;
++        } else if (compareJsonString(pResponseStr, &tokens[i], JSMN_STRING, (PCHAR) "SecretAccessKey")) {
++            secretKeyLen = (UINT32) (tokens[i + 1].end - tokens[i + 1].start);
++            CHK(secretKeyLen <= MAX_SECRET_KEY_LEN, STATUS_INVALID_API_CALL_RETURN_JSON);
++            secretKey = pResponseStr + tokens[i + 1].start;
++            i++;
++        } else if (compareJsonString(pResponseStr, &tokens[i], JSMN_STRING, (PCHAR) "Token")) {
++            sessionTokenLen = (UINT32) (tokens[i + 1].end - tokens[i + 1].start);
++            CHK(sessionTokenLen <= MAX_SESSION_TOKEN_LEN, STATUS_INVALID_API_CALL_RETURN_JSON);
++            sessionToken = pResponseStr + tokens[i + 1].start;
++            i++;
++        } else if (compareJsonString(pResponseStr, &tokens[i], JSMN_STRING, (PCHAR) "Expiration")) {
++            expirationTimestampLen = (UINT32) (tokens[i + 1].end - tokens[i + 1].start);
++            CHK(expirationTimestampLen <= MAX_EXPIRATION_LEN, STATUS_INVALID_API_CALL_RETURN_JSON);
++            expirationTimestamp = pResponseStr + tokens[i + 1].start;
++            MEMCPY(expirationTimestampStr, expirationTimestamp, expirationTimestampLen);
++            expirationTimestampStr[expirationTimestampLen] = '\0';
++            i++;
++        }
++    }
++
++    CHK(accessKeyId != NULL && secretKey != NULL && sessionToken != NULL, STATUS_ECS_AUTH_RSP_FAILED);
++
++    currentTime = pEcsCredentialProvider->getCurrentTimeFn(pEcsCredentialProvider->customData);
++    CHK_STATUS(convertTimestampToEpoch(expirationTimestampStr, currentTime / HUNDREDS_OF_NANOS_IN_A_SECOND, &expiration));
++    DLOGD("Ecs credential expiration time %" PRIu64, expiration / HUNDREDS_OF_NANOS_IN_A_SECOND);
++
++    if (pEcsCredentialProvider->pAwsCredentials != NULL) {
++        freeAwsCredentials(&pEcsCredentialProvider->pAwsCredentials);
++        pEcsCredentialProvider->pAwsCredentials = NULL;
++    }
++
++    // Fix-up the expiration to be no more than max enforced token rotation to avoid extra token rotations
++    // as we are caching the returned value which is likely to be an hour but we are enforcing max
++    // rotation to be more frequent.
++    expiration = MIN(expiration, currentTime + MAX_ENFORCED_TOKEN_EXPIRATION_DURATION);
++
++    CHK_STATUS(createAwsCredentials(accessKeyId, accessKeyIdLen, secretKey, secretKeyLen, sessionToken, sessionTokenLen, expiration,
++                                    &pEcsCredentialProvider->pAwsCredentials));
++
++CleanUp:
++
++    LEAVES();
++    return retStatus;
++}
++
++STATUS ecsCurlHandler(PEcsCredentialProvider pEcsCredentialProvider)
++{
++    ENTERS();
++    STATUS retStatus = STATUS_SUCCESS;
++    UINT64 currentTime;
++    UINT32 formatLen = 0;
++    CHAR serviceUrl[MAX_URI_CHAR_LEN + 1];
++    PRequestInfo pRequestInfo = NULL;
++    CallInfo callInfo;
++
++    MEMSET(&callInfo, 0x00, SIZEOF(CallInfo));
++
++    // Refresh the credentials
++    currentTime = pEcsCredentialProvider->getCurrentTimeFn(pEcsCredentialProvider->customData);
++
++    CHK(pEcsCredentialProvider->pAwsCredentials == NULL ||
++            currentTime + ECS_CREDENTIAL_FETCH_GRACE_PERIOD > pEcsCredentialProvider->pAwsCredentials->expiration,
++        retStatus);
++
++    formatLen = SNPRINTF(serviceUrl, MAX_URI_CHAR_LEN, "%s/%s", pEcsCredentialProvider->ecsGetCredentialEndpoint,
++                         pEcsCredentialProvider->ecsGetCredentialResource);
++    CHK(formatLen > 0 && formatLen < MAX_URI_CHAR_LEN, STATUS_ECS_AUTH_URI_FAILED);
++
++    // Form a new request info based on the params
++    CHK_STATUS(createRequestInfo(serviceUrl, NULL, pEcsCredentialProvider->port, DEFAULT_AWS_REGION, NULL, NULL, NULL, SSL_CERTIFICATE_TYPE_PEM,
++                                 DEFAULT_USER_AGENT_NAME, ECS_REQUEST_CONNECTION_TIMEOUT, ECS_REQUEST_COMPLETION_TIMEOUT, DEFAULT_LOW_SPEED_LIMIT,
++                                 DEFAULT_LOW_SPEED_TIME_LIMIT, pEcsCredentialProvider->pAwsCredentials, &pRequestInfo));
++
++    callInfo.pRequestInfo = pRequestInfo;
++
++    // Append the Ecs header
++    CHK_STATUS(setRequestHeader(pRequestInfo, ECS_AUTH_TOKEN_HEADER, 0, pEcsCredentialProvider->token, 0));
++
++    // Perform a blocking call
++    CHK_STATUS(pEcsCredentialProvider->serviceCallFn(pRequestInfo, &callInfo));
++
++    // Parse the response and get the credentials
++    CHK_STATUS(parseEcsResponse(pEcsCredentialProvider, &callInfo));
++
++CleanUp:
++
++    if (pRequestInfo != NULL) {
++        freeRequestInfo(&pRequestInfo);
++    }
++
++    releaseCallInfo(&callInfo);
++
++    return retStatus;
++}
++
++STATUS getHostPort(PCHAR pUrl, PCHAR* ppStart, PCHAR* ppEnd)
++{
++    STATUS retStatus = STATUS_SUCCESS;
++    PCHAR pStart = NULL, pEnd = NULL, pCurPtr;
++    UINT32 urlLen;
++    BOOL iterate = TRUE;
++
++    CHK(pUrl != NULL && ppStart != NULL && ppEnd != NULL, STATUS_NULL_ARG);
++
++    // We know for sure url is NULL terminated
++    urlLen = (UINT32) STRNLEN(pUrl, MAX_URI_CHAR_LEN + 1);
++
++    // Start from the schema delimiter
++    pStart = STRSTR(pUrl, PORT_DELIMITER_STRING);
++    CHK(pStart != NULL, STATUS_INVALID_ARG);
++
++    // Advance the pStart past the delimiter
++    pStart += (ARRAY_SIZE(PORT_DELIMITER_STRING) - 1);
++
++    // Ensure we are not past the string
++    CHK(pUrl + urlLen > pStart, STATUS_INVALID_ARG);
++
++    // Set the end first
++    pEnd = pUrl + urlLen;
++
++    // Find the delimiter which would indicate end of the host - either one of "/:?"
++    pCurPtr = pStart;
++    while (iterate && pCurPtr <= pEnd) {
++        switch (*pCurPtr) {
++            case '/':
++            case ':':
++            case '?':
++                iterate = FALSE;
++
++                // Set the new end value
++                pEnd = pCurPtr;
++            default:
++                pCurPtr++;
++        }
++    }
++
++CleanUp:
++
++    if (ppStart != NULL) {
++        *ppStart = pStart;
++    }
++
++    if (ppEnd != NULL) {
++        *ppEnd = pEnd;
++    }
++
++    return retStatus;
++}
+diff --git a/src/source/Common/EcsCredentialProvider.h b/src/source/Common/EcsCredentialProvider.h
+new file mode 100644
+index 0000000..c113af2
+--- /dev/null
++++ b/src/source/Common/EcsCredentialProvider.h
+@@ -0,0 +1,64 @@
++
++#ifndef __KINESIS_VIDEO_ECS_CREDENTIAL_PROVIDER_INCLUDE_I__
++#define __KINESIS_VIDEO_ECS_CREDENTIAL_PROVIDER_INCLUDE_I__
++
++#pragma once
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++#define ECS_REQUEST_CONNECTION_TIMEOUT (3 * HUNDREDS_OF_NANOS_IN_A_SECOND)
++#define ECS_REQUEST_COMPLETION_TIMEOUT (5 * HUNDREDS_OF_NANOS_IN_A_SECOND)
++#define ECS_AUTH_TOKEN_HEADER          "authorization"
++
++/**
++ * Service call callback functionality
++ */
++typedef STATUS (*BlockingServiceCallFunc)(PRequestInfo, PCallInfo);
++
++/**
++ * Grace period which is added to the current time to determine whether the extracted credentials are still valid
++ */
++#define ECS_CREDENTIAL_FETCH_GRACE_PERIOD                                                                                                            \
++    (5 * HUNDREDS_OF_NANOS_IN_A_SECOND + MIN_STREAMING_TOKEN_EXPIRATION_DURATION + STREAMING_TOKEN_EXPIRATION_GRACE_PERIOD)
++
++typedef struct __EcsCredentialProvider EcsCredentialProvider;
++struct __EcsCredentialProvider {
++    // First member should be the abstract credential provider
++    AwsCredentialProvider credentialProvider;
++
++    // Current time functionality - optional
++    GetCurrentTimeFunc getCurrentTimeFn;
++
++    // Custom data supplied to time function
++    UINT64 customData;
++
++    // Ecs credential endpoint
++    CHAR ecsGetCredentialEndpoint[MAX_URI_CHAR_LEN + 1];
++    CHAR ecsGetCredentialResource[MAX_URI_CHAR_LEN + 1];
++    CHAR token[MAX_ECS_TOKEN_LEN + 1];
++    UINT32 port;
++
++    // Static Aws Credentials structure with the pointer following the main allocation
++    PAwsCredentials pAwsCredentials;
++
++    // Service call functionality
++    BlockingServiceCallFunc serviceCallFn;
++};
++typedef struct __EcsCredentialProvider* PEcsCredentialProvider;
++
++////////////////////////////////////////////////////////////////////////
++// Callback function implementations
++////////////////////////////////////////////////////////////////////////
++STATUS createEcsCredentialProviderWithTime(PCHAR, PCHAR, GetCurrentTimeFunc, UINT64, BlockingServiceCallFunc, PAwsCredentialProvider*);
++STATUS getEcsCredentials(PAwsCredentialProvider, PAwsCredentials*);
++
++// internal functions
++STATUS ecsCurlHandler(PEcsCredentialProvider);
++STATUS parseEcsResponse(PEcsCredentialProvider, PCallInfo);
++STATUS getHostPort(PCHAR, PCHAR*, PCHAR*);
++#ifdef __cplusplus
++}
++#endif
++#endif /* __KINESIS_VIDEO_ECS_CREDENTIAL_PROVIDER_INCLUDE_I__ */
+diff --git a/src/source/Common/Include_i.h b/src/source/Common/Include_i.h
+index 56ae2ae..f931b57 100644
+--- a/src/source/Common/Include_i.h
++++ b/src/source/Common/Include_i.h
+@@ -73,9 +73,11 @@ typedef struct __CRYPTO_dynlock_value* PCRYPTO_dynlock_value;
+ #if defined(KVS_BUILD_WITH_LWS)
+ #include "Lws/LwsCall.h"
+ #include "Lws/LwsIotCredentialProvider.h"
++#include "Lws/LwsEcsCredentialProvider.h"
+ #endif
+ 
+ #include "IotCredentialProvider.h"
++#include "EcsCredentialProvider.h"
+ #include "AwsV4Signer.h"
+ #include "Util.h"
+ #include "RequestInfo.h"
+diff --git a/src/source/Common/IotCredentialProvider.c b/src/source/Common/IotCredentialProvider.c
+index a61218c..c95af1d 100644
+--- a/src/source/Common/IotCredentialProvider.c
++++ b/src/source/Common/IotCredentialProvider.c
+@@ -214,7 +214,7 @@ STATUS iotCurlHandler(PIotCredentialProvider pIotCredentialProvider)
+     CHK(formatLen > 0 && formatLen < MAX_URI_CHAR_LEN, STATUS_IOT_FAILED);
+ 
+     // Form a new request info based on the params
+-    CHK_STATUS(createRequestInfo(serviceUrl, NULL, DEFAULT_AWS_REGION, pIotCredentialProvider->caCertPath, pIotCredentialProvider->certPath,
++    CHK_STATUS(createRequestInfo(serviceUrl, NULL, DEFAULT_SSL_PORT_NUMBER, DEFAULT_AWS_REGION, pIotCredentialProvider->caCertPath, pIotCredentialProvider->certPath,
+                                  pIotCredentialProvider->privateKeyPath, SSL_CERTIFICATE_TYPE_PEM, DEFAULT_USER_AGENT_NAME,
+                                  IOT_REQUEST_CONNECTION_TIMEOUT, IOT_REQUEST_COMPLETION_TIMEOUT, DEFAULT_LOW_SPEED_LIMIT,
+                                  DEFAULT_LOW_SPEED_TIME_LIMIT, pIotCredentialProvider->pAwsCredentials, &pRequestInfo));
+diff --git a/src/source/Common/Lws/LwsCall.c b/src/source/Common/Lws/LwsCall.c
+index f06b588..cc069dd 100644
+--- a/src/source/Common/Lws/LwsCall.c
++++ b/src/source/Common/Lws/LwsCall.c
+@@ -88,6 +88,90 @@ CleanUp:
+     return retStatus;
+ }
+ 
++STATUS blockingLwsHttpCall(PRequestInfo pRequestInfo, PCallInfo pCallInfo)
++{
++    ENTERS();
++    STATUS retStatus = STATUS_SUCCESS;
++    PCHAR pHostStart, pHostEnd;
++    CHAR path[MAX_URI_CHAR_LEN + 1];
++    struct lws_context* lwsContext = NULL;
++    struct lws_context_creation_info creationInfo;
++    struct lws_client_connect_info connectInfo;
++    struct lws* clientLws = NULL;
++    volatile INT32 retVal = 0;
++    struct lws_protocols lwsProtocols[2];
++
++    CHK(pRequestInfo != NULL && pCallInfo != NULL, STATUS_NULL_ARG);
++
++    // Prepare the signaling channel protocols array
++    MEMSET(lwsProtocols, 0x00, SIZEOF(lwsProtocols));
++    lwsProtocols[0].name = HTTP_SCHEME_NAME;
++    lwsProtocols[0].callback = lwsIotCallbackRoutine;
++    lwsProtocols[1].name = NULL;
++    lwsProtocols[1].callback = NULL;
++
++    // Prepare the LWS context
++    MEMSET(&creationInfo, 0x00, SIZEOF(struct lws_context_creation_info));
++    creationInfo.options = 0;
++    creationInfo.port = CONTEXT_PORT_NO_LISTEN;
++    creationInfo.protocols = lwsProtocols;
++    creationInfo.timeout_secs = pRequestInfo->completionTimeout / HUNDREDS_OF_NANOS_IN_A_SECOND;
++    creationInfo.gid = -1;
++    creationInfo.uid = -1;
++    creationInfo.fd_limit_per_thread = 1 + 1 + 1;
++    creationInfo.client_ssl_ca_filepath = pRequestInfo->certPath;
++    creationInfo.client_ssl_cert_filepath = pRequestInfo->sslCertPath;
++    creationInfo.client_ssl_private_key_filepath = pRequestInfo->sslPrivateKeyPath;
++
++    CHK(NULL != (lwsContext = lws_create_context(&creationInfo)), STATUS_IOT_CREATE_LWS_CONTEXT_FAILED);
++
++    // Execute the LWS REST call
++    MEMSET(&connectInfo, 0x00, SIZEOF(struct lws_client_connect_info));
++    connectInfo.context = lwsContext;
++    connectInfo.ssl_connection = LCCSCF_ALLOW_INSECURE;
++    connectInfo.port = pRequestInfo->port;
++
++    CHK_STATUS(getRequestHost(pRequestInfo->url, &pHostStart, &pHostEnd));
++
++    // Store the path
++    STRNCPY(path, pHostEnd, MAX_URI_CHAR_LEN);
++    path[MAX_URI_CHAR_LEN] = '\0';
++
++    // NULL terminate the host
++    *pHostEnd = '\0';
++
++    connectInfo.address = pHostStart;
++    connectInfo.path = path;
++    connectInfo.host = connectInfo.address;
++    connectInfo.method = HTTP_REQUEST_VERB_GET_STRING;
++    connectInfo.protocol = lwsProtocols[0].name;
++    connectInfo.pwsi = &clientLws;
++
++    connectInfo.opaque_user_data = (PVOID) pCallInfo;
++
++    CHK(NULL != lws_client_connect_via_info(&connectInfo), STATUS_IOT_CREATE_LWS_CONTEXT_FAILED);
++
++    while (retVal >= 0 && !ATOMIC_LOAD_BOOL(&pCallInfo->pRequestInfo->terminating)) {
++        retVal = lws_service(lwsContext, 0);
++    }
++
++CleanUp:
++
++    if (lwsContext != NULL) {
++        // Trigger termination
++        ATOMIC_STORE_BOOL(&pCallInfo->pRequestInfo->terminating, TRUE);
++
++        // Cancel the ongoing service if any
++        lws_cancel_service(lwsContext);
++
++        // Destroy the context
++        lws_context_destroy(lwsContext);
++    }
++
++    LEAVES();
++    return retStatus;
++}
++
+ INT32 lwsIotCallbackRoutine(struct lws* wsi, enum lws_callback_reasons reason, PVOID user, PVOID pDataIn, size_t dataSize)
+ {
+     UNUSED_PARAM(user);
+@@ -259,4 +343,4 @@ CleanUp:
+     } else {
+         return retValue;
+     }
+-}
+\ No newline at end of file
++}
+diff --git a/src/source/Common/Lws/LwsCall.h b/src/source/Common/Lws/LwsCall.h
+index e334506..2601250 100644
+--- a/src/source/Common/Lws/LwsCall.h
++++ b/src/source/Common/Lws/LwsCall.h
+@@ -12,6 +12,7 @@ extern "C" {
+ #define IOT_LWS_SEND_BUFFER_SIZE (LWS_PRE + MAX_URI_CHAR_LEN)
+ 
+ STATUS blockingLwsCall(PRequestInfo, PCallInfo);
++STATUS blockingLwsHttpCall(PRequestInfo, PCallInfo);
+ INT32 lwsIotCallbackRoutine(struct lws*, enum lws_callback_reasons, PVOID, PVOID, size_t);
+ 
+ #ifdef __cplusplus
+diff --git a/src/source/Common/Lws/LwsEcsCredentialProvider.c b/src/source/Common/Lws/LwsEcsCredentialProvider.c
+new file mode 100644
+index 0000000..94c26f5
+--- /dev/null
++++ b/src/source/Common/Lws/LwsEcsCredentialProvider.c
+@@ -0,0 +1,16 @@
++/**
++ * Kinesis Video Producer ECS based Credential Provider for libWebSockets
++ */
++#define LOG_CLASS "LwsEcsCredentialProvider"
++#include "../Include_i.h"
++
++STATUS createLwsEcsCredentialProvider(PCHAR ecsCredentialFullUri, PCHAR token, PAwsCredentialProvider* ppCredentialProvider)
++{
++    return createLwsEcsCredentialProviderWithTime(ecsCredentialFullUri, token, commonDefaultGetCurrentTimeFunc, 0, ppCredentialProvider);
++}
++
++STATUS createLwsEcsCredentialProviderWithTime(PCHAR ecsCredentialFullUri, PCHAR token, GetCurrentTimeFunc getCurrentTimeFn, UINT64 customData,
++                                              PAwsCredentialProvider* ppCredentialProvider)
++{
++    return createEcsCredentialProviderWithTime(ecsCredentialFullUri, token, getCurrentTimeFn, customData, blockingLwsHttpCall, ppCredentialProvider);
++}
+diff --git a/src/source/Common/Lws/LwsEcsCredentialProvider.h b/src/source/Common/Lws/LwsEcsCredentialProvider.h
+new file mode 100644
+index 0000000..93caa4c
+--- /dev/null
++++ b/src/source/Common/Lws/LwsEcsCredentialProvider.h
+@@ -0,0 +1,16 @@
++
++#ifndef __KINESIS_VIDEO_LWS_ECS_CREDENTIAL_PROVIDER_INCLUDE_I__
++#define __KINESIS_VIDEO_LWS_ECS_CREDENTIAL_PROVIDER_INCLUDE_I__
++
++#pragma once
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++STATUS blockingLwsHttpCall(PRequestInfo, PCallInfo);
++
++#ifdef __cplusplus
++}
++#endif
++#endif /* __KINESIS_VIDEO_LWS_ECS_CREDENTIAL_PROVIDER_INCLUDE_I__ */
+diff --git a/src/source/Common/RequestInfo.c b/src/source/Common/RequestInfo.c
+index adda706..f38e280 100644
+--- a/src/source/Common/RequestInfo.c
++++ b/src/source/Common/RequestInfo.c
+@@ -1,7 +1,7 @@
+ #define LOG_CLASS "RequestInfo"
+ #include "Include_i.h"
+ 
+-STATUS createRequestInfo(PCHAR url, PCHAR body, PCHAR region, PCHAR certPath, PCHAR sslCertPath, PCHAR sslPrivateKeyPath,
++STATUS createRequestInfo(PCHAR url, PCHAR body, UINT32 port, PCHAR region, PCHAR certPath, PCHAR sslCertPath, PCHAR sslPrivateKeyPath,
+                          SSL_CERTIFICATE_TYPE certType, PCHAR userAgent, UINT64 connectionTimeout, UINT64 completionTimeout, UINT64 lowSpeedLimit,
+                          UINT64 lowSpeedTimeLimit, PAwsCredentials pAwsCredentials, PRequestInfo* ppRequestInfo)
+ {
+@@ -28,6 +28,7 @@ STATUS createRequestInfo(PCHAR url, PCHAR body, PCHAR region, PCHAR certPath, PC
+     pRequestInfo->connectionTimeout = connectionTimeout;
+     ATOMIC_STORE_BOOL(&pRequestInfo->terminating, FALSE);
+     pRequestInfo->bodySize = bodySize;
++    pRequestInfo->port = port;
+     pRequestInfo->currentTime = GETTIME();
+     pRequestInfo->callAfter = pRequestInfo->currentTime;
+     STRNCPY(pRequestInfo->region, region, MAX_REGION_NAME_LEN);
+-- 
+2.20.1 (Apple Git-117)
+
diff --git a/samples/CMakeLists.txt b/samples/CMakeLists.txt
index ae738c135..1fe10e4ef 100644
--- a/samples/CMakeLists.txt
+++ b/samples/CMakeLists.txt
@@ -18,7 +18,7 @@ if(GST_FOUND)
   endif()
 
   pkg_check_modules(GLIB2 REQUIRED glib-2.0)
-  pkg_check_modules(GST_APP REQUIRED gstreamer-app-1.0)
+  pkg_check_modules(GST_APP REQUIRED gstreamer-app-1.0 gstreamer-sdp-1.0)
   pkg_check_modules(GOBJ2 REQUIRED gobject-2.0)
   message("gstreamer found. Will build gstreamer samples")
 
@@ -73,6 +73,17 @@ if(GST_FOUND)
   install(TARGETS kvsWebrtcClientMasterGstSample
     RUNTIME DESTINATION bin
   )
+
+  add_executable(
+    kvsWebrtcClientMasterGstRtspSample
+    Common.c
+    kvsWebRTCClientMasterGstRtspSample.c
+  )
+  target_link_libraries(kvsWebrtcClientMasterGstRtspSample kvsWebrtcClient kvsWebrtcSignalingClient ${GST_SAMPLE_LIBRARIES} kvsCommonLws kvspicUtils websockets)
+
+  install(TARGETS kvsWebrtcClientMasterGstRtspSample
+    RUNTIME DESTINATION bin
+  )
 endif()
 
 install(TARGETS kvsWebrtcClientMaster kvsWebrtcClientViewer discoverNatBehavior
diff --git a/samples/Common.c b/samples/Common.c
index f1c9f961a..ac01444bd 100644
--- a/samples/Common.c
+++ b/samples/Common.c
@@ -141,13 +141,14 @@ CleanUp:
 
     return retStatus;
 }
-
+/**
+ * @brief the thread of media sender.
+ */
 PVOID mediaSenderRoutine(PVOID customData)
 {
     STATUS retStatus = STATUS_SUCCESS;
     PSampleConfiguration pSampleConfiguration = (PSampleConfiguration) customData;
     TID videoSenderTid = INVALID_TID_VALUE, audioSenderTid = INVALID_TID_VALUE;
-
     MUTEX_LOCK(pSampleConfiguration->sampleConfigurationObjLock);
     while (!ATOMIC_LOAD_BOOL(&pSampleConfiguration->connected) && !ATOMIC_LOAD_BOOL(&pSampleConfiguration->appTerminateFlag)) {
         CVAR_WAIT(pSampleConfiguration->cvar, pSampleConfiguration->sampleConfigurationObjLock, 5 * HUNDREDS_OF_NANOS_IN_A_SECOND);
@@ -173,7 +174,8 @@ PVOID mediaSenderRoutine(PVOID customData)
     }
 
 CleanUp:
-
+    // clean the flag of the media thread.
+    ATOMIC_STORE_BOOL(&pSampleConfiguration->mediaThreadStarted, FALSE);
     CHK_LOG_ERR(retStatus);
     return NULL;
 }
@@ -435,6 +437,10 @@ STATUS createSampleStreamingSession(PSampleConfiguration pSampleConfiguration, P
     pSampleStreamingSession = (PSampleStreamingSession) MEMCALLOC(1, SIZEOF(SampleStreamingSession));
     CHK(pSampleStreamingSession != NULL, STATUS_NOT_ENOUGH_MEMORY);
 
+    if (pSampleConfiguration->createStreamingSessionPreHook != NULL) {
+        pSampleConfiguration->createStreamingSessionPreHook(pSampleConfiguration, pSampleStreamingSession);
+    }
+
     if (isMaster) {
         STRCPY(pSampleStreamingSession->peerId, peerId);
     } else {
@@ -447,6 +453,7 @@ STATUS createSampleStreamingSession(PSampleConfiguration pSampleConfiguration, P
     // if we're the viewer, we control the trickle ice mode
     pSampleStreamingSession->remoteCanTrickleIce = !isMaster && pSampleConfiguration->trickleIce;
 
+    ATOMIC_STORE_BOOL(&pSampleConfiguration->terminateCodecFlag, FALSE);
     ATOMIC_STORE_BOOL(&pSampleStreamingSession->terminateFlag, FALSE);
     ATOMIC_STORE_BOOL(&pSampleStreamingSession->candidateGatheringDone, FALSE);
 
@@ -460,13 +467,16 @@ STATUS createSampleStreamingSession(PSampleConfiguration pSampleConfiguration, P
     }
 
     // Declare that we support H264,Profile=42E01F,level-asymmetry-allowed=1,packetization-mode=1 and Opus
-    CHK_STATUS(addSupportedCodec(pSampleStreamingSession->pPeerConnection, RTC_CODEC_H264_PROFILE_42E01F_LEVEL_ASYMMETRY_ALLOWED_PACKETIZATION_MODE));
-    CHK_STATUS(addSupportedCodec(pSampleStreamingSession->pPeerConnection, RTC_CODEC_OPUS));
+    if (!ATOMIC_LOAD_BOOL(&pSampleConfiguration->codecConfigLatched)) {
+        DLOGE("codec is not setup.");
+    }
+    CHK_STATUS(addSupportedCodec(pSampleStreamingSession->pPeerConnection, pSampleConfiguration->codecConfiguration.videoStream.codec));
+    CHK_STATUS(addSupportedCodec(pSampleStreamingSession->pPeerConnection, pSampleConfiguration->codecConfiguration.audioStream.codec));
 
     // Add a SendRecv Transceiver of type video
     videoTrack.kind = MEDIA_STREAM_TRACK_KIND_VIDEO;
-    videoTrack.codec = RTC_CODEC_H264_PROFILE_42E01F_LEVEL_ASYMMETRY_ALLOWED_PACKETIZATION_MODE;
-    videoRtpTransceiverInit.direction = RTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV;
+    videoTrack.codec = pSampleConfiguration->codecConfiguration.videoStream.codec;
+    videoRtpTransceiverInit.direction = RTC_RTP_TRANSCEIVER_DIRECTION_SENDONLY;
     STRCPY(videoTrack.streamId, "myKvsVideoStream");
     STRCPY(videoTrack.trackId, "myVideoTrack");
     CHK_STATUS(addTransceiver(pSampleStreamingSession->pPeerConnection, &videoTrack, &videoRtpTransceiverInit,
@@ -477,8 +487,8 @@ STATUS createSampleStreamingSession(PSampleConfiguration pSampleConfiguration, P
 
     // Add a SendRecv Transceiver of type video
     audioTrack.kind = MEDIA_STREAM_TRACK_KIND_AUDIO;
-    audioTrack.codec = RTC_CODEC_OPUS;
-    audioRtpTransceiverInit.direction = RTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV;
+    audioTrack.codec = pSampleConfiguration->codecConfiguration.audioStream.codec;
+    audioRtpTransceiverInit.direction = RTC_RTP_TRANSCEIVER_DIRECTION_SENDONLY;
     STRCPY(audioTrack.streamId, "myKvsVideoStream");
     STRCPY(audioTrack.trackId, "myAudioTrack");
     CHK_STATUS(addTransceiver(pSampleStreamingSession->pPeerConnection, &audioTrack, &audioRtpTransceiverInit,
@@ -491,6 +501,11 @@ STATUS createSampleStreamingSession(PSampleConfiguration pSampleConfiguration, P
                                                          sampleSenderBandwidthEstimationHandler));
     pSampleStreamingSession->firstFrame = TRUE;
     pSampleStreamingSession->startUpLatency = 0;
+
+    if (pSampleConfiguration->createStreamingSessionPostHook != NULL) {
+        pSampleConfiguration->createStreamingSessionPostHook(pSampleConfiguration, pSampleStreamingSession);
+    }
+
 CleanUp:
 
     if (STATUS_FAILED(retStatus) && pSampleStreamingSession != NULL) {
@@ -520,6 +535,10 @@ STATUS freeSampleStreamingSession(PSampleStreamingSession* ppSampleStreamingSess
 
     ATOMIC_STORE_BOOL(&pSampleStreamingSession->terminateFlag, TRUE);
 
+    if (pSampleConfiguration->freeStreamingSessionPreHook != NULL) {
+        pSampleConfiguration->freeStreamingSessionPreHook(pSampleConfiguration, pSampleStreamingSession);
+    }
+
     if (pSampleStreamingSession->shutdownCallback != NULL) {
         pSampleStreamingSession->shutdownCallback(pSampleStreamingSession->shutdownCallbackCustomData, pSampleStreamingSession);
     }
@@ -544,6 +563,9 @@ STATUS freeSampleStreamingSession(PSampleStreamingSession* ppSampleStreamingSess
     CHK_LOG_ERR(freePeerConnection(&pSampleStreamingSession->pPeerConnection));
     SAFE_MEMFREE(pSampleStreamingSession);
 
+    if (pSampleConfiguration->freeStreamingSessionPostHook != NULL) {
+        pSampleConfiguration->freeStreamingSessionPostHook(pSampleConfiguration, pSampleStreamingSession);
+    }
 CleanUp:
 
     CHK_LOG_ERR(retStatus);
@@ -685,14 +707,21 @@ STATUS createSampleConfiguration(PCHAR channelName, SIGNALING_CHANNEL_ROLE_TYPE
     STATUS retStatus = STATUS_SUCCESS;
     PCHAR pAccessKey, pSecretKey, pSessionToken, pLogLevel;
     PSampleConfiguration pSampleConfiguration = NULL;
+    PRtspCameraConfiguration pRtspCameraConfiguration = NULL;
     UINT32 logLevel = LOG_LEVEL_DEBUG;
+    PCHAR pRtspChannel, pRtspUri, pRtspUsername, pRtspPassword;
 
     CHK(ppSampleConfiguration != NULL, STATUS_NULL_ARG);
 
     CHK(NULL != (pSampleConfiguration = (PSampleConfiguration) MEMCALLOC(1, SIZEOF(SampleConfiguration))), STATUS_NOT_ENOUGH_MEMORY);
-
-#ifdef IOT_CORE_ENABLE_CREDENTIALS
+#ifdef ECS_ENABLE_CREDENTIALS
+    PCHAR pEcsToken, pEcsCredentialFullUri;
+    CHK_ERR((pEcsToken = getenv(ECS_AUTH_TOKEN)) != NULL, STATUS_INVALID_OPERATION, "AWS_CONTAINER_AUTHORIZATION_TOKEN must be set");
+    CHK_ERR((pEcsCredentialFullUri = getenv(ECS_CREDENTIALS_FULL_URI)) != NULL, STATUS_INVALID_OPERATION,
+            "AWS_CONTAINER_CREDENTIALS_FULL_URI must be set");
+#elif defined(IOT_CORE_ENABLE_CREDENTIALS)
     PCHAR pIotCoreCredentialEndPoint, pIotCoreCert, pIotCorePrivateKey, pIotCoreRoleAlias, pIotCoreThingName;
+    CHK_ERR((pIotCoreThingName = getenv(IOT_CORE_THING_NAME)) != NULL, STATUS_INVALID_OPERATION, "AWS_IOT_CORE_THING_NAME must be set");
     CHK_ERR((pIotCoreCredentialEndPoint = getenv(IOT_CORE_CREDENTIAL_ENDPOINT)) != NULL, STATUS_INVALID_OPERATION,
             "AWS_IOT_CORE_CREDENTIAL_ENDPOINT must be set");
     CHK_ERR((pIotCoreCert = getenv(IOT_CORE_CERT)) != NULL, STATUS_INVALID_OPERATION, "AWS_IOT_CORE_CERT must be set");
@@ -703,6 +732,29 @@ STATUS createSampleConfiguration(PCHAR channelName, SIGNALING_CHANNEL_ROLE_TYPE
     CHK_ERR((pSecretKey = getenv(SECRET_KEY_ENV_VAR)) != NULL, STATUS_INVALID_OPERATION, "AWS_SECRET_ACCESS_KEY must be set");
 #endif
 
+    pRtspCameraConfiguration = &pSampleConfiguration->rtspCameraConfiguration;
+    CHK_ERR((pRtspChannel = getenv(RTSP_CHANNEL)) != NULL, STATUS_INVALID_OPERATION, "RTSP_CHANNEL must be set");
+    CHK_ERR((pRtspUri = getenv(RTSP_URI)) != NULL, STATUS_INVALID_OPERATION, "RTSP_URI must be set");
+
+    CHK(STRNLEN(pRtspChannel, MAX_URI_CHAR_LEN + 1) <= MAX_URI_CHAR_LEN && STRNLEN(pRtspUri, MAX_CHANNEL_NAME_LEN + 1) <= MAX_CHANNEL_NAME_LEN,
+        STATUS_INVALID_ARG);
+    STRNCPY(pRtspCameraConfiguration->uri, pRtspUri, MAX_URI_CHAR_LEN);
+    STRNCPY(pRtspCameraConfiguration->channel, pRtspChannel, MAX_CHANNEL_NAME_LEN);
+
+    pRtspUsername = getenv(RTSP_USERNAME);
+    pRtspPassword = getenv(RTSP_PASSWORD);
+
+    if (pRtspUsername == NULL || pRtspPassword == NULL || pRtspUsername[0] == '\0' || pRtspPassword[0] == '\0') {
+        MEMSET(pRtspCameraConfiguration->username, 0, SAMPLE_RTSP_USERNAME_LEN);
+        MEMSET(pRtspCameraConfiguration->password, 0, SAMPLE_RTSP_PASSWORD_LEN);
+    } else {
+        CHK(STRNLEN(pRtspUsername, SAMPLE_RTSP_USERNAME_LEN + 1) <= SAMPLE_RTSP_USERNAME_LEN &&
+                STRNLEN(pRtspPassword, SAMPLE_RTSP_PASSWORD_LEN + 1) <= SAMPLE_RTSP_PASSWORD_LEN,
+            STATUS_INVALID_ARG);
+        STRNCPY(pRtspCameraConfiguration->username, pRtspUsername, SAMPLE_RTSP_USERNAME_LEN);
+        STRNCPY(pRtspCameraConfiguration->password, pRtspPassword, SAMPLE_RTSP_PASSWORD_LEN);
+    }
+
     pSessionToken = getenv(SESSION_TOKEN_ENV_VAR);
     pSampleConfiguration->enableFileLogging = FALSE;
     if (NULL != getenv(ENABLE_FILE_LOGGING)) {
@@ -721,15 +773,11 @@ STATUS createSampleConfiguration(PCHAR channelName, SIGNALING_CHANNEL_ROLE_TYPE
     }
 
     SET_LOGGER_LOG_LEVEL(logLevel);
-
-#ifdef IOT_CORE_ENABLE_CREDENTIALS
-    CHK_STATUS(createLwsIotCredentialProvider(pIotCoreCredentialEndPoint,
-                                              pIotCoreCert,
-                                              pIotCorePrivateKey,
-                                              pSampleConfiguration->pCaCertPath,
-                                              pIotCoreRoleAlias,
-                                              channelName,
-                                              &pSampleConfiguration->pCredentialProvider));
+#ifdef ECS_ENABLE_CREDENTIALS
+    CHK_STATUS(createLwsEcsCredentialProvider(pEcsCredentialFullUri, pEcsToken, &pSampleConfiguration->pCredentialProvider));
+#elif defined(IOT_CORE_ENABLE_CREDENTIALS)
+    CHK_STATUS(createLwsIotCredentialProvider(pIotCoreCredentialEndPoint, pIotCoreCert, pIotCorePrivateKey, pSampleConfiguration->pCaCertPath,
+                                              pIotCoreRoleAlias, pIotCoreThingName, &pSampleConfiguration->pCredentialProvider));
 #else
     CHK_STATUS(
         createStaticCredentialProvider(pAccessKey, 0, pSecretKey, 0, pSessionToken, 0, MAX_UINT64, &pSampleConfiguration->pCredentialProvider));
@@ -778,6 +826,10 @@ STATUS createSampleConfiguration(PCHAR channelName, SIGNALING_CHANNEL_ROLE_TYPE
     ATOMIC_STORE_BOOL(&pSampleConfiguration->recreateSignalingClient, FALSE);
     ATOMIC_STORE_BOOL(&pSampleConfiguration->connected, FALSE);
 
+    pSampleConfiguration->codecConfLock = MUTEX_CREATE(TRUE);
+    ATOMIC_STORE_BOOL(&pSampleConfiguration->terminateCodecFlag, FALSE);
+    ATOMIC_STORE_BOOL(&pSampleConfiguration->codecConfigLatched, FALSE);
+
     CHK_STATUS(timerQueueCreate(&pSampleConfiguration->timerQueueHandle));
 
     CHK_STATUS(stackQueueCreate(&pSampleConfiguration->pregeneratedCertificates));
@@ -1045,17 +1097,21 @@ STATUS freeSampleConfiguration(PSampleConfiguration* ppSampleConfiguration)
         MUTEX_FREE(pSampleConfiguration->signalingSendMessageLock);
     }
 
+    if (IS_VALID_MUTEX_VALUE(pSampleConfiguration->codecConfLock)) {
+        MUTEX_FREE(pSampleConfiguration->codecConfLock);
+    }
+
     if (IS_VALID_CVAR_VALUE(pSampleConfiguration->cvar)) {
         CVAR_FREE(pSampleConfiguration->cvar);
     }
-
-#ifdef IOT_CORE_ENABLE_CREDENTIALS
+#ifdef ECS_ENABLE_CREDENTIALS
+    freeEcsCredentialProvider(&pSampleConfiguration->pCredentialProvider);
+#elif defined(IOT_CORE_ENABLE_CREDENTIALS)
     freeIotCredentialProvider(&pSampleConfiguration->pCredentialProvider);
 #else
     freeStaticCredentialProvider(&pSampleConfiguration->pCredentialProvider);
 #endif
 
-
     if (IS_VALID_TIMER_QUEUE_HANDLE(pSampleConfiguration->timerQueueHandle)) {
         if (pSampleConfiguration->iceCandidatePairStatsTimerId != MAX_UINT32) {
             retStatus = timerQueueCancelTimer(pSampleConfiguration->timerQueueHandle, pSampleConfiguration->iceCandidatePairStatsTimerId,
diff --git a/samples/Samples.h b/samples/Samples.h
index 02037eda8..7cc3da295 100644
--- a/samples/Samples.h
+++ b/samples/Samples.h
@@ -11,6 +11,24 @@ extern "C" {
 #endif
 
 #include <com/amazonaws/kinesis/video/webrtcclient/Include.h>
+#include <gst/gst.h>
+#include <gst/app/gstappsink.h>
+
+#define STATUS_SAMPLE_BASE   0x70000000
+#define STATUS_SAMPLE_FAILED STATUS_SAMPLE_BASE + 0x00000001
+
+#define STATUS_GST_BASE              STATUS_SAMPLE_BASE + 0x01000000
+#define STATUS_GST_FAILED            STATUS_GST_BASE + 0x00000001
+#define STATUS_GST_DUMMY_SINK        STATUS_GST_BASE + 0x00000002
+#define STATUS_GST_VIDEO_SINK        STATUS_GST_BASE + 0x00000003
+#define STATUS_GST_AUDIO_SINK        STATUS_GST_BASE + 0x00000004
+#define STATUS_GST_LINK_ELEMENT      STATUS_GST_BASE + 0x00000005
+#define STATUS_GST_VIDEO_ELEMENT     STATUS_GST_BASE + 0x00000006
+#define STATUS_GST_AUDIO_ELEMENT     STATUS_GST_BASE + 0x00000007
+#define STATUS_GST_DUMMY_ELEMENT     STATUS_GST_BASE + 0x00000008
+#define STATUS_GST_EMPTY_ELEMENT     STATUS_GST_BASE + 0x00000009
+#define STATUS_GST_UNSUPPORTED_VIDEO STATUS_GST_BASE + 0x0000000A
+#define STATUS_GST_UNSUPPORTED_AUDIO STATUS_GST_BASE + 0x0000000B
 
 #define NUMBER_OF_H264_FRAME_FILES               1500
 #define NUMBER_OF_OPUS_FRAME_FILES               618
@@ -40,14 +58,30 @@ extern "C" {
 #define SAMPLE_HASH_TABLE_BUCKET_COUNT  50
 #define SAMPLE_HASH_TABLE_BUCKET_LENGTH 2
 
+#define SAMPLE_RTSP_USERNAME_LEN MAX_CHANNEL_NAME_LEN
+#define SAMPLE_RTSP_PASSWORD_LEN MAX_CHANNEL_NAME_LEN
+
 #define IOT_CORE_CREDENTIAL_ENDPOINT ((PCHAR) "AWS_IOT_CORE_CREDENTIAL_ENDPOINT")
 #define IOT_CORE_CERT                ((PCHAR) "AWS_IOT_CORE_CERT")
 #define IOT_CORE_PRIVATE_KEY         ((PCHAR) "AWS_IOT_CORE_PRIVATE_KEY")
 #define IOT_CORE_ROLE_ALIAS          ((PCHAR) "AWS_IOT_CORE_ROLE_ALIAS")
 #define IOT_CORE_THING_NAME          ((PCHAR) "AWS_IOT_CORE_THING_NAME")
 
+#define ECS_AUTH_TOKEN           ((PCHAR) "AWS_CONTAINER_AUTHORIZATION_TOKEN")
+#define ECS_CREDENTIALS_FULL_URI ((PCHAR) "AWS_CONTAINER_CREDENTIALS_FULL_URI")
+
+#define RTSP_CHANNEL  ((PCHAR) "AWS_RTSP_CHANNEL")
+#define RTSP_URI      ((PCHAR) "AWS_RTSP_URI")
+#define RTSP_USERNAME ((PCHAR) "AWS_RTSP_USERNAME")
+#define RTSP_PASSWORD ((PCHAR) "AWS_RTSP_PASSWORD")
+
+#define GST_ELEMENT_NAME_MAX_LEN 256
+
 /* Uncomment the following line in order to enable IoT credentials checks in the provided samples */
-//#define IOT_CORE_ENABLE_CREDENTIALS  1
+//#define IOT_CORE_ENABLE_CREDENTIALS 1
+#define ECS_ENABLE_CREDENTIALS 1
+
+typedef VOID (*StreamingSessionHook)(PSampleConfiguration, PSampleStreamingSession);
 
 typedef enum {
     SAMPLE_STREAMING_VIDEO_ONLY,
@@ -66,12 +100,35 @@ typedef struct {
     UINT64 prevTs;
 } RtcMetricsHistory, *PRtcMetricsHistory;
 
+#define GST_ENCODING_NAME_MAX_LEN 256
+typedef struct {
+    RTC_CODEC codec;
+    CHAR encodingName[GST_ENCODING_NAME_MAX_LEN];
+    UINT32 payloadType;
+    UINT32 clockRate;
+} CodecStreamConf, *PCodecStreamConf;
+
+typedef struct {
+    GMainLoop* mainLoop;  //!< the main runner for gstreamer.
+    GstElement* pipeline; //!< the pipeline for the rtsp url.
+    CodecStreamConf videoStream;
+    CodecStreamConf audioStream;
+} CodecConfiguration, *PCodecConfiguration;
+
+typedef struct {
+    CHAR uri[MAX_URI_CHAR_LEN];              //!< the rtsp url.
+    CHAR channel[MAX_CHANNEL_NAME_LEN];      //!< the signaling channgel for the rtsp url.
+    CHAR username[SAMPLE_RTSP_USERNAME_LEN]; //!< the username to login the rtsp url.
+    CHAR password[SAMPLE_RTSP_PASSWORD_LEN]; //!< the password to login the rtsp url.
+} RtspCameraConfiguration, *PRtspCameraConfiguration;
+
 typedef struct {
     volatile ATOMIC_BOOL appTerminateFlag;
     volatile ATOMIC_BOOL interrupted;
-    volatile ATOMIC_BOOL mediaThreadStarted;
+    volatile ATOMIC_BOOL mediaThreadStarted; //!< the flag to identify the status of the media thread.
     volatile ATOMIC_BOOL recreateSignalingClient;
     volatile ATOMIC_BOOL connected;
+
     BOOL useTestSrc;
     ChannelInfo channelInfo;
     PCHAR pCaCertPath;
@@ -102,16 +159,25 @@ typedef struct {
     UINT64 customData;
     PSampleStreamingSession sampleStreamingSessionList[DEFAULT_MAX_CONCURRENT_STREAMING_SESSION];
     UINT32 streamingSessionCount;
-    MUTEX streamingSessionListReadLock;
+    MUTEX streamingSessionListReadLock; //!< the lock of streaming session.
     UINT32 iceUriCount;
     SignalingClientCallbacks signalingClientCallbacks;
     SignalingClientInfo clientInfo;
     RtcStats rtcIceCandidatePairMetrics;
 
     MUTEX signalingSendMessageLock;
-
     UINT32 pregenerateCertTimerId;
     PStackQueue pregeneratedCertificates; // Max MAX_RTCCONFIGURATION_CERTIFICATES certificates
+
+    StreamingSessionHook createStreamingSessionPreHook;
+    StreamingSessionHook createStreamingSessionPostHook;
+    StreamingSessionHook freeStreamingSessionPreHook;
+    StreamingSessionHook freeStreamingSessionPostHook;
+    volatile ATOMIC_BOOL terminateCodecFlag;
+    volatile ATOMIC_BOOL codecConfigLatched;
+    MUTEX codecConfLock;
+    CodecConfiguration codecConfiguration;           //!< the configuration of gstreamer.
+    RtspCameraConfiguration rtspCameraConfiguration; //!< the configuration of rtsp camera.
 } SampleConfiguration, *PSampleConfiguration;
 
 typedef struct {
@@ -138,6 +204,7 @@ struct __SampleStreamingSession {
     TID receiveAudioVideoSenderTid;
     UINT64 offerReceiveTime;
     UINT64 startUpLatency;
+    BOOL firstKeyFrame; //!< the first key frame of this session is sent or not.
     BOOL firstFrame;
     RtcMetricsHistory rtcMetricsHistory;
     BOOL remoteCanTrickleIce;
diff --git a/samples/kvsWebRTCClientMaster.c b/samples/kvsWebRTCClientMaster.c
index dcaaa7c65..3f258d42e 100644
--- a/samples/kvsWebRTCClientMaster.c
+++ b/samples/kvsWebRTCClientMaster.c
@@ -21,12 +21,7 @@ INT32 main(INT32 argc, CHAR* argv[])
 
     // do trickleIce by default
     printf("[KVS Master] Using trickleICE by default\n");
-
-#ifdef IOT_CORE_ENABLE_CREDENTIALS
-    CHK_ERR((pChannelName = getenv(IOT_CORE_THING_NAME)) != NULL, STATUS_INVALID_OPERATION, "AWS_IOT_CORE_THING_NAME must be set");
-#else
     pChannelName = argc > 1 ? argv[1] : SAMPLE_CHANNEL_NAME;
-#endif
 
     retStatus = createSampleConfiguration(pChannelName, SIGNALING_CHANNEL_ROLE_TYPE_MASTER, TRUE, TRUE, &pSampleConfiguration);
     if (retStatus != STATUS_SUCCESS) {
@@ -272,7 +267,7 @@ CleanUp:
 
     CHK_LOG_ERR(retStatus);
 
-    return (PVOID) (ULONG_PTR) retStatus;
+    return (PVOID)(ULONG_PTR) retStatus;
 }
 
 PVOID sendAudioPackets(PVOID args)
@@ -340,7 +335,7 @@ PVOID sendAudioPackets(PVOID args)
 
 CleanUp:
 
-    return (PVOID) (ULONG_PTR) retStatus;
+    return (PVOID)(ULONG_PTR) retStatus;
 }
 
 PVOID sampleReceiveVideoFrame(PVOID args)
@@ -360,5 +355,5 @@ PVOID sampleReceiveVideoFrame(PVOID args)
 
 CleanUp:
 
-    return (PVOID) (ULONG_PTR) retStatus;
+    return (PVOID)(ULONG_PTR) retStatus;
 }
diff --git a/samples/kvsWebRTCClientMasterGstRtspSample.c b/samples/kvsWebRTCClientMasterGstRtspSample.c
new file mode 100644
index 000000000..a417474ca
--- /dev/null
+++ b/samples/kvsWebRTCClientMasterGstRtspSample.c
@@ -0,0 +1,922 @@
+#include "Samples.h"
+
+// gstreamere related.
+#include <gst/gst.h>
+#include <gst/app/gstappsink.h>
+#include <gst/sdp/gstsdpmessage.h>
+#include <gst/gststructure.h>
+#include <gst/gstcaps.h>
+#include <gst/rtsp/rtsp.h>
+
+extern PSampleConfiguration gSampleConfiguration;
+
+#define GST_STRUCT_FIELD_MEDIA         "media"
+#define GST_STRUCT_FIELD_MEDIA_VIDEO   "video"
+#define GST_STRUCT_FIELD_MEDIA_AUDIO   "audio"
+#define GST_STRUCT_FIELD_ENCODING      "encoding-name"
+#define GST_STRUCT_FIELD_PKT_MODE      "packetization-mode"
+#define GST_STRUCT_FIELD_PROFILE_LV_ID "profile-level-id"
+#define GST_STRUCT_FIELD_ENCODING_H264 "H264"
+#define GST_STRUCT_FIELD_ENCODING_VP8  "VP8"
+#define GST_STRUCT_FIELD_ENCODING_PCMU "PCMU"
+#define GST_STRUCT_FIELD_ENCODING_PCMA "PCMA"
+#define GST_STRUCT_FIELD_ENCODING_OPUS "opus"
+#define GST_STRUCT_FIELD_ENCODING_G722 "G722"
+
+#define GST_STRUCT_FIELD_PAYLOAD_TYPE "payload"
+#define GST_STRUCT_FIELD_CLOCK_RATE   "clock-rate"
+
+// #define VERBOSE
+/**
+ * @brief quitting the main loop of gstreamer.
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+STATUS gstreamerCloseRtspsrc(PSampleConfiguration pSampleConfiguration)
+{
+    STATUS retStatus = STATUS_SUCCESS;
+    DLOGD("terminating rtsp src.");
+    MUTEX_LOCK(pSampleConfiguration->codecConfLock);
+    PCodecConfiguration pGstConfiguration = &pSampleConfiguration->codecConfiguration;
+    if (pGstConfiguration->mainLoop != NULL) {
+        g_main_loop_quit(pGstConfiguration->mainLoop);
+    }
+    MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    return retStatus;
+}
+
+GstFlowReturn on_new_sample(GstElement* sink, gpointer udata, UINT64 trackid)
+{
+    GstBuffer* buffer;
+    BOOL isDroppable, delta;
+    GstFlowReturn ret = GST_FLOW_OK;
+    GstSample* sample = NULL;
+    GstMapInfo info;
+    GstSegment* segment;
+    GstClockTime buf_pts;
+    Frame frame;
+    STATUS status;
+    PSampleConfiguration pSampleConfiguration = (PSampleConfiguration) udata;
+    PCodecConfiguration pGstConfiguration = &pSampleConfiguration->codecConfiguration;
+
+    PSampleStreamingSession pSampleStreamingSession = NULL;
+    PRtcRtpTransceiver pRtcRtpTransceiver = NULL;
+    UINT32 i;
+
+    if (pSampleConfiguration == NULL) {
+        printf("[KVS GStreamer Master] on_new_sample(): operation returned status code: 0x%08x \n", STATUS_NULL_ARG);
+        goto CleanUp;
+    }
+
+    info.data = NULL;
+    sample = gst_app_sink_pull_sample(GST_APP_SINK(sink));
+    buffer = gst_sample_get_buffer(sample);
+    isDroppable = GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_CORRUPTED) || //!< the buffer data is corrupted.
+        GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DECODE_ONLY) || (GST_BUFFER_FLAGS(buffer) == GST_BUFFER_FLAG_DISCONT) ||
+        (GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DISCONT) && GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DELTA_UNIT)) ||
+        // drop if buffer contains header only and has invalid timestamp
+        !GST_BUFFER_PTS_IS_VALID(buffer);
+
+    if (!isDroppable) {
+        delta = GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+
+        frame.flags = delta ? FRAME_FLAG_NONE : FRAME_FLAG_KEY_FRAME;
+        segment = gst_sample_get_segment(sample);
+        buf_pts = gst_segment_to_running_time(segment, GST_FORMAT_TIME, buffer->pts);
+        if (!GST_CLOCK_TIME_IS_VALID(buf_pts)) {
+            printf("[KVS GStreamer Master] Frame contains invalid PTS dropping the frame. \n");
+        }
+        if (!(gst_buffer_map(buffer, &info, GST_MAP_READ))) {
+            printf("[KVS GStreamer Master] on_new_sample(): Gst buffer mapping failed\n");
+            goto CleanUp;
+        }
+        frame.trackId = trackid;
+        frame.duration = 0;
+        frame.version = FRAME_CURRENT_VERSION;
+        frame.size = (UINT32) info.size;
+        frame.frameData = (PBYTE) info.data;
+
+        MUTEX_LOCK(pSampleConfiguration->streamingSessionListReadLock);
+        for (i = 0; i < pSampleConfiguration->streamingSessionCount; ++i) {
+            pSampleStreamingSession = pSampleConfiguration->sampleStreamingSessionList[i];
+            if (pSampleStreamingSession->firstKeyFrame == FALSE && frame.flags != FRAME_FLAG_KEY_FRAME) {
+                continue;
+            } else {
+                pSampleStreamingSession->firstKeyFrame = TRUE;
+            }
+            frame.index = (UINT32) ATOMIC_INCREMENT(&pSampleStreamingSession->frameIndex);
+
+            if (trackid == DEFAULT_AUDIO_TRACK_ID) {
+                pRtcRtpTransceiver = pSampleStreamingSession->pAudioRtcRtpTransceiver;
+                frame.presentationTs = buf_pts * DEFAULT_TIME_UNIT_IN_NANOS;
+                frame.decodingTs = frame.presentationTs;
+            } else {
+                pRtcRtpTransceiver = pSampleStreamingSession->pVideoRtcRtpTransceiver;
+                frame.presentationTs = buf_pts * DEFAULT_TIME_UNIT_IN_NANOS;
+                frame.decodingTs = frame.presentationTs;
+            }
+            status = writeFrame(pRtcRtpTransceiver, &frame);
+            if (status != STATUS_SRTP_NOT_READY_YET && status != STATUS_SUCCESS) {
+#ifdef VERBOSE
+                printf("writeFrame() failed with 0x%08x", status);
+#endif
+            }
+        }
+        MUTEX_UNLOCK(pSampleConfiguration->streamingSessionListReadLock);
+    }
+
+CleanUp:
+
+    if (info.data != NULL) {
+        gst_buffer_unmap(buffer, &info);
+    }
+
+    if (sample != NULL) {
+        gst_sample_unref(sample);
+    }
+    if (ATOMIC_LOAD_BOOL(&pSampleConfiguration->appTerminateFlag) || ATOMIC_LOAD_BOOL(&pSampleConfiguration->terminateCodecFlag)) {
+        gstreamerCloseRtspsrc(pSampleConfiguration);
+        ret = GST_FLOW_EOS;
+    }
+    return ret;
+}
+
+GstFlowReturn on_new_sample_video(GstElement* sink, gpointer udata)
+{
+    return on_new_sample(sink, udata, DEFAULT_VIDEO_TRACK_ID);
+}
+
+GstFlowReturn on_new_sample_audio(GstElement* sink, gpointer udata)
+{
+    return on_new_sample(sink, udata, DEFAULT_AUDIO_TRACK_ID);
+}
+
+/**
+ * @brief the dummy sink for the output of rtspsrc.
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+STATUS gstreamerDummySink(PSampleConfiguration pSampleConfiguration, GstElement** ppDummySink, PCHAR name)
+{
+    STATUS retStatus = STATUS_SUCCESS;
+    CHAR elementName[GST_ELEMENT_NAME_MAX_LEN];
+    GstElement* pipeline = NULL;
+    GstElement* dummySink = NULL;
+    BOOL locked = FALSE;
+
+    MUTEX_LOCK(pSampleConfiguration->codecConfLock);
+    locked = TRUE;
+    pipeline = (GstElement*) pSampleConfiguration->codecConfiguration.pipeline;
+    CHK(pipeline != NULL, STATUS_GST_DUMMY_SINK);
+    SNPRINTF(elementName, GST_ELEMENT_NAME_MAX_LEN, "dummySink%s", name);
+    dummySink = gst_element_factory_make("fakesink", elementName);
+    CHK(dummySink != NULL, STATUS_GST_DUMMY_SINK);
+    gst_bin_add_many(GST_BIN(pipeline), dummySink, NULL);
+
+    if (locked) {
+        MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    }
+    *ppDummySink = dummySink;
+    return retStatus;
+CleanUp:
+    // release the resource when we fail to create the pipeline.
+    gst_caps_unref(dummySink);
+    if (locked) {
+        MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    }
+    *ppDummySink = NULL;
+    return retStatus;
+}
+
+/**
+ * @brief the video sink for the output of rtspsrc.
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+STATUS gstreamerVideoSink(PSampleConfiguration pSampleConfiguration, GstElement** ppVideoQueue, PCHAR name)
+{
+    STATUS retStatus = STATUS_SUCCESS;
+    PCodecStreamConf pCodecStreamConf;
+    GstElement* pipeline;
+    CHAR elementName[GST_ELEMENT_NAME_MAX_LEN];
+    GstElement* videoQueue = NULL;
+    GstElement *videoDepay = NULL, *videoFilter = NULL, *videoAppSink = NULL;
+    GstCaps* videoCaps = NULL;
+    BOOL locked = FALSE;
+
+    MUTEX_LOCK(pSampleConfiguration->codecConfLock);
+    locked = TRUE;
+
+    pCodecStreamConf = &pSampleConfiguration->codecConfiguration.videoStream;
+    pipeline = (GstElement*) pSampleConfiguration->codecConfiguration.pipeline;
+    CHK(pCodecStreamConf != NULL && pipeline != NULL, STATUS_GST_VIDEO_ELEMENT);
+
+    SNPRINTF(elementName, GST_ELEMENT_NAME_MAX_LEN, "videoQueue%s", name);
+    videoQueue = gst_element_factory_make("queue", elementName);
+    if (pCodecStreamConf->codec == RTC_CODEC_H264_PROFILE_42E01F_LEVEL_ASYMMETRY_ALLOWED_PACKETIZATION_MODE) {
+        videoDepay = gst_element_factory_make("rtph264depay", "videoDepay");
+        videoCaps = gst_caps_new_simple("video/x-h264", "stream-format", G_TYPE_STRING, "byte-stream", "alignment", G_TYPE_STRING, "au", NULL);
+    } else if (pCodecStreamConf->codec == RTC_CODEC_VP8) {
+        videoDepay = gst_element_factory_make("rtpvp8depay", "videoDepay");
+        videoCaps = gst_caps_new_simple("video/x-vp8", "profile", G_TYPE_STRING, "0", NULL);
+    } else {
+        DLOGE("unsupported video type");
+        CHK(FALSE, STATUS_GST_UNSUPPORTED_AUDIO);
+    }
+    CHK(videoCaps != NULL, STATUS_GST_VIDEO_ELEMENT);
+
+    videoFilter = gst_element_factory_make("capsfilter", "videoFilter");
+    videoAppSink = gst_element_factory_make("appsink", "videoAppSink");
+
+    CHK(videoQueue != NULL, STATUS_GST_VIDEO_ELEMENT);
+    CHK(videoDepay != NULL && videoFilter != NULL && videoAppSink != NULL, STATUS_GST_VIDEO_ELEMENT);
+
+    g_object_set(G_OBJECT(videoFilter), "caps", videoCaps, NULL);
+    gst_caps_unref(videoCaps);
+    videoCaps = NULL;
+    // configure appsink
+    g_object_set(G_OBJECT(videoAppSink), "emit-signals", TRUE, "sync", FALSE, NULL);
+    g_signal_connect(videoAppSink, "new-sample", G_CALLBACK(on_new_sample_video), pSampleConfiguration);
+    // link all the elements.
+    gst_bin_add_many(GST_BIN(pipeline), videoQueue, videoDepay, videoFilter, videoAppSink, NULL);
+    CHK(gst_element_link_many(videoQueue, videoDepay, videoFilter, videoAppSink, NULL), STATUS_GST_VIDEO_ELEMENT);
+    if (locked) {
+        MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    }
+    *ppVideoQueue = videoQueue;
+    return retStatus;
+CleanUp:
+    // release the resource when we fail to create the pipeline.
+    gst_object_unref(videoQueue);
+    gst_object_unref(videoDepay);
+    gst_object_unref(videoCaps);
+    gst_object_unref(videoFilter);
+    gst_object_unref(videoAppSink);
+    if (locked) {
+        MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    }
+    *ppVideoQueue = NULL;
+    return retStatus;
+}
+
+/**
+ * @brief the audio sink for the output of rtspsrc.
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+STATUS gstreamerAudioSink(PSampleConfiguration pSampleConfiguration, GstElement** ppAudioQueue, PCHAR name)
+{
+    STATUS retStatus = STATUS_SUCCESS;
+    PCodecStreamConf pCodecStreamConf;
+    CHAR elementName[GST_ELEMENT_NAME_MAX_LEN];
+    GstElement* pipeline;
+    GstElement* audioQueue = NULL;
+    GstElement *audioDepay = NULL, *audioFilter = NULL, *audioAppSink = NULL;
+    GstCaps* audioCaps = NULL;
+    BOOL locked = FALSE;
+
+    MUTEX_LOCK(pSampleConfiguration->codecConfLock);
+    locked = TRUE;
+
+    pCodecStreamConf = &pSampleConfiguration->codecConfiguration.audioStream;
+    pipeline = (GstElement*) pSampleConfiguration->codecConfiguration.pipeline;
+    CHK(pCodecStreamConf != NULL && pipeline != NULL, STATUS_GST_VIDEO_ELEMENT);
+
+    SNPRINTF(elementName, GST_ELEMENT_NAME_MAX_LEN, "audioQueue%s", name);
+    audioQueue = gst_element_factory_make("queue", "audioQueue");
+    if (pCodecStreamConf->codec == RTC_CODEC_OPUS) {
+        audioDepay = gst_element_factory_make("rtpopusdepay", "audioDepay");
+        audioCaps = gst_caps_new_simple("audio/x-opus", "rate", G_TYPE_INT, 48000, "channels", G_TYPE_INT, 2, NULL);
+    } else if (pCodecStreamConf->codec == RTC_CODEC_MULAW) {
+        audioDepay = gst_element_factory_make("rtppcmudepay", "audioDepay");
+        audioCaps = gst_caps_new_simple("audio/x-mulaw", "rate", G_TYPE_INT, 8000, "channels", G_TYPE_INT, 1, NULL);
+    } else if (pCodecStreamConf->codec == RTC_CODEC_ALAW) {
+        audioDepay = gst_element_factory_make("rtppcmadepay", "audioDepay");
+        audioCaps = gst_caps_new_simple("audio/x-alaw", "rate", G_TYPE_INT, 8000, "channels", G_TYPE_INT, 1, NULL);
+    } else {
+        DLOGE("unsupported audio type");
+        CHK(FALSE, STATUS_GST_UNSUPPORTED_AUDIO);
+    }
+    CHK(audioCaps != NULL, STATUS_GST_AUDIO_ELEMENT);
+
+    audioFilter = gst_element_factory_make("capsfilter", "audioFilter");
+    audioAppSink = gst_element_factory_make("appsink", "audioAppSink");
+
+    CHK(audioQueue != NULL, STATUS_GST_AUDIO_ELEMENT);
+    CHK(audioDepay != NULL && audioFilter != NULL && audioAppSink != NULL, STATUS_GST_AUDIO_ELEMENT);
+
+    g_object_set(G_OBJECT(audioFilter), "caps", audioCaps, NULL);
+    gst_caps_unref(audioCaps);
+    audioCaps = NULL;
+
+    g_object_set(G_OBJECT(audioAppSink), "emit-signals", TRUE, "sync", FALSE, NULL);
+    g_signal_connect(audioAppSink, "new-sample", G_CALLBACK(on_new_sample_audio), pSampleConfiguration);
+    gst_bin_add_many(GST_BIN(pipeline), audioQueue, audioDepay, audioFilter, audioAppSink, NULL);
+    CHK(gst_element_link_many(audioQueue, audioDepay, audioFilter, audioAppSink, NULL), STATUS_GST_AUDIO_ELEMENT);
+    if (locked) {
+        MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    }
+    *ppAudioQueue = audioQueue;
+    return retStatus;
+CleanUp:
+    // release the resource when we fail to create the pipeline.
+    gst_object_unref(audioQueue);
+    gst_object_unref(audioDepay);
+    gst_object_unref(audioFilter);
+    gst_object_unref(audioAppSink);
+    if (locked) {
+        MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    }
+    *ppAudioQueue = NULL;
+    return retStatus;
+}
+
+/**
+ * @brief
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+static void rtspsrcOnSdpProbe(GstElement* rtspsrc, GstSDPMessage* sdp, gpointer udata)
+{
+    guint i;
+    gchar* sdpString = gst_sdp_message_as_text(sdp);
+    guint mediaNum = gst_sdp_message_medias_len(sdp);
+    DLOGD("SDP from RTSP:%s", sdpString);
+    DLOGD("mediaNum:%d", mediaNum);
+
+    for (i = 0; i < mediaNum; i++) {
+        const GstSDPMedia* sdpMedia = gst_sdp_message_get_media(sdp, i);
+        gchar* mediaText = gst_sdp_media_as_text(sdpMedia);
+        DLOGD("media text:%s", mediaText);
+        g_free(mediaText);
+    }
+    g_free(sdpString);
+}
+
+/**
+ * @brief   the callback is invoked when there is no coming.
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+static void rtspsrcOnPadAddedProbe(GstElement* element, GstPad* pad, gpointer udata)
+{
+    STATUS retStatus = STATUS_SUCCESS;
+    PSampleConfiguration pSampleConfiguration = (PSampleConfiguration) udata;
+    PCodecConfiguration pGstConfiguration = &pSampleConfiguration->codecConfiguration;
+    PCodecStreamConf pCodecStreamConf = NULL;
+    BOOL video = FALSE;
+    BOOL audio = FALSE;
+    // gstreamer
+    GstElement* pipeline = (GstElement*) pGstConfiguration->pipeline;
+    gchar* srcPadName = NULL;
+    GstCaps* srcPadTemplateCaps = NULL;
+    GstCaps* srcPadCurrentCaps = NULL;
+    GstStructure* srcPadStructure = NULL;
+    GstElement* nextElement = NULL;
+    gchar* media = NULL;
+    GstCaps* audioCaps = NULL;
+    guint curCapsNum;
+    BOOL locked = FALSE;
+
+    srcPadName = gst_pad_get_name(pad);
+    srcPadTemplateCaps = gst_pad_get_pad_template_caps(pad);
+    DLOGD("A new pad template %s was created", srcPadName);
+    srcPadCurrentCaps = gst_pad_get_current_caps(pad);
+    curCapsNum = gst_caps_get_size(srcPadCurrentCaps);
+
+    MUTEX_LOCK(pSampleConfiguration->codecConfLock);
+    locked = TRUE;
+    for (guint i = 0; i < curCapsNum; i++) {
+        srcPadStructure = gst_caps_get_structure(srcPadCurrentCaps, i);
+
+        if (gst_structure_has_field(srcPadStructure, GST_STRUCT_FIELD_MEDIA) == TRUE &&
+            gst_structure_has_field(srcPadStructure, GST_STRUCT_FIELD_ENCODING) == TRUE) {
+            media = gst_structure_get_string(srcPadStructure, GST_STRUCT_FIELD_MEDIA);
+            const gchar* encoding_name = gst_structure_get_string(srcPadStructure, GST_STRUCT_FIELD_ENCODING);
+            DLOGD("media:%s, encoding_name:%s", media, encoding_name);
+
+            if (STRCMP(media, GST_STRUCT_FIELD_MEDIA_VIDEO) == 0) {
+                video = TRUE;
+                pCodecStreamConf = &pGstConfiguration->videoStream;
+                pCodecStreamConf->codec = -1;
+                // h264
+                if (STRCMP(encoding_name, GST_STRUCT_FIELD_ENCODING_H264) == 0) {
+                    pCodecStreamConf->codec = RTC_CODEC_H264_PROFILE_42E01F_LEVEL_ASYMMETRY_ALLOWED_PACKETIZATION_MODE;
+                    // vp8
+                } else if (STRCMP(encoding_name, GST_STRUCT_FIELD_ENCODING_VP8) == 0) {
+                    pCodecStreamConf->codec = RTC_CODEC_VP8;
+                    // others
+                } else {
+                    DLOGW("unsupported video format");
+                }
+            } else if (STRCMP(media, GST_STRUCT_FIELD_MEDIA_AUDIO) == 0) {
+                audio = TRUE;
+                pCodecStreamConf = &pGstConfiguration->audioStream;
+                pCodecStreamConf->codec = -1;
+                if (STRCMP(encoding_name, GST_STRUCT_FIELD_ENCODING_PCMU) == 0) {
+                    pCodecStreamConf->codec = RTC_CODEC_MULAW;
+                } else if (STRCMP(encoding_name, GST_STRUCT_FIELD_ENCODING_PCMA) == 0) {
+                    pCodecStreamConf->codec = RTC_CODEC_ALAW;
+                } else if (STRCMP(encoding_name, GST_STRUCT_FIELD_ENCODING_OPUS) == 0) {
+                    pCodecStreamConf->codec = RTC_CODEC_OPUS;
+                } else {
+                    DLOGW("unsupported audio format");
+                }
+            }
+            DLOGD("codec:%d", pCodecStreamConf->codec);
+        }
+
+        if (gst_structure_has_field(srcPadStructure, GST_STRUCT_FIELD_PAYLOAD_TYPE) == TRUE) {
+            gint payloadType;
+            gst_structure_get_int(srcPadStructure, GST_STRUCT_FIELD_PAYLOAD_TYPE, &payloadType);
+            DLOGD("payload:%d", payloadType);
+            pCodecStreamConf->payloadType = payloadType;
+        }
+        if (gst_structure_has_field(srcPadStructure, GST_STRUCT_FIELD_CLOCK_RATE) == TRUE) {
+            gint clock_rate;
+            gst_structure_get_int(srcPadStructure, GST_STRUCT_FIELD_CLOCK_RATE, &clock_rate);
+            DLOGD("clock-rate:%d", clock_rate);
+            pCodecStreamConf->clockRate = clock_rate;
+        }
+    }
+    gst_caps_unref(srcPadCurrentCaps);
+    if (locked) {
+        MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    }
+    CHK_STATUS(gstreamerDummySink(pSampleConfiguration, &nextElement, media));
+    CHK(nextElement != NULL, STATUS_GST_EMPTY_ELEMENT);
+    CHK(gst_element_link_filtered(element, nextElement, srcPadTemplateCaps) == TRUE, STATUS_GST_LINK_ELEMENT);
+CleanUp:
+    if (locked) {
+        MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    }
+    g_free(srcPadName);
+    gst_caps_unref(srcPadTemplateCaps);
+    CHK_LOG_ERR(retStatus);
+    if (retStatus != STATUS_SUCCESS) {
+        gstreamerCloseRtspsrc(pSampleConfiguration);
+    }
+}
+
+/**
+ * @brief   the callback is invoked when there is no coming.
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+static void rtspsrcOnNoMorePadsProbe(GstElement* element, gpointer udata)
+{
+    PSampleConfiguration pSampleConfiguration = (PSampleConfiguration) udata;
+    ATOMIC_STORE_BOOL(&pSampleConfiguration->codecConfigLatched, TRUE);
+    gstreamerCloseRtspsrc(pSampleConfiguration);
+}
+
+/**
+ * @brief   the callback is invoked when a new pad is coming.
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+static void rtspsrcOnPadAdded(GstElement* element, GstPad* pad, gpointer udata)
+{
+    STATUS retStatus = STATUS_SUCCESS;
+    PSampleConfiguration pSampleConfiguration = (PSampleConfiguration) udata;
+    PCodecConfiguration pGstConfiguration = &pSampleConfiguration->codecConfiguration;
+    PCodecStreamConf pCodecStreamConf = NULL;
+    GstElement* pipeline = (GstElement*) pGstConfiguration->pipeline;
+    gchar* srcPadName = NULL;
+    GstCaps* srcPadTemplateCaps = NULL;
+    GstCaps* srcPadCurrentCaps = NULL;
+    GstStructure* srcPadStructure = NULL;
+    GstElement* nextElement = NULL;
+    gint payloadType = 0;
+    BOOL video = FALSE;
+    BOOL audio = FALSE;
+    BOOL locked = FALSE;
+
+    MUTEX_LOCK(pSampleConfiguration->codecConfLock);
+    locked = TRUE;
+    srcPadName = gst_pad_get_name(pad);
+    srcPadTemplateCaps = gst_pad_get_pad_template_caps(pad);
+    DLOGD("A new pad template %s was created", srcPadName);
+
+    srcPadCurrentCaps = gst_pad_get_current_caps(pad);
+    guint curCapsNum = gst_caps_get_size(srcPadCurrentCaps);
+
+    for (guint i = 0; i < curCapsNum; i++) {
+        srcPadStructure = gst_caps_get_structure(srcPadCurrentCaps, i);
+        if (gst_structure_has_field(srcPadStructure, GST_STRUCT_FIELD_MEDIA) == TRUE) {
+            const gchar* media_value = gst_structure_get_string(srcPadStructure, GST_STRUCT_FIELD_MEDIA);
+            DLOGD("media_value:%s", media_value);
+            if (STRCMP(media_value, GST_STRUCT_FIELD_MEDIA_VIDEO) == 0) {
+                video = TRUE;
+                pCodecStreamConf = &pGstConfiguration->videoStream;
+            } else if (STRCMP(media_value, GST_STRUCT_FIELD_MEDIA_AUDIO) == 0) {
+                audio = TRUE;
+                pCodecStreamConf = &pGstConfiguration->audioStream;
+            }
+        }
+        if (gst_structure_has_field(srcPadStructure, GST_STRUCT_FIELD_PAYLOAD_TYPE) == TRUE) {
+            gst_structure_get_int(srcPadStructure, GST_STRUCT_FIELD_PAYLOAD_TYPE, &payloadType);
+            DLOGD("payload:%d", payloadType);
+        }
+    }
+    gst_caps_unref(srcPadCurrentCaps);
+    if (pCodecStreamConf != NULL && pCodecStreamConf->payloadType != payloadType) {
+        DLOGW("payload type conflict");
+    }
+    if (video == TRUE && pCodecStreamConf->payloadType == payloadType) {
+        DLOGD("connecting video sink");
+        CHK_STATUS(gstreamerVideoSink(pSampleConfiguration, &nextElement, srcPadName));
+    } else if (audio == TRUE && pCodecStreamConf->payloadType == payloadType) {
+        DLOGD("connecting audio sink");
+        CHK_STATUS(gstreamerAudioSink(pSampleConfiguration, &nextElement, srcPadName));
+    } else {
+        DLOGW("connecting dummy sink");
+        CHK_STATUS(gstreamerDummySink(pSampleConfiguration, &nextElement, srcPadName));
+    }
+    if (locked) {
+        MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    }
+    CHK(nextElement != NULL, STATUS_GST_EMPTY_ELEMENT);
+    CHK(gst_element_link_filtered(element, nextElement, srcPadTemplateCaps) == TRUE, STATUS_GST_LINK_ELEMENT);
+    gst_element_set_state(pipeline, GST_STATE_PLAYING);
+CleanUp:
+    if (locked) {
+        MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    }
+    g_free(srcPadName);
+    gst_caps_unref(srcPadTemplateCaps);
+    CHK_LOG_ERR(retStatus);
+    if (retStatus != STATUS_SUCCESS) {
+        gstreamerCloseRtspsrc(pSampleConfiguration);
+    }
+}
+
+/**
+ * @brief this callback is invoked when pad is removed
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+static void rtspsrcOnPadRemoved(GstElement* element, GstPad* pad, gpointer udata)
+{
+    PSampleConfiguration pSampleConfiguration = (PSampleConfiguration) udata;
+    gstreamerCloseRtspsrc(pSampleConfiguration);
+}
+
+/**
+ * @brief the callback is invoked when the error happens on the bus.
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+/* This function is called when an error message is posted on the bus */
+static void busMsgErrorCallback(GstBus* bus, GstMessage* msg, gpointer* udata)
+{
+    GError* err;
+    gchar* debug_info;
+    PSampleConfiguration pSampleConfiguration = (PSampleConfiguration) udata;
+    gst_message_parse_error(msg, &err, &debug_info);
+    DLOGE("err code: %d: %d", err->code, GST_RTSP_EINVAL);
+    DLOGE("Error received from element %s: %s\n", GST_OBJECT_NAME(msg->src), err->message);
+    DLOGE("Debugging information: %s\n", debug_info ? debug_info : "none");
+    g_clear_error(&err);
+    g_free(debug_info);
+    gstreamerCloseRtspsrc(pSampleConfiguration);
+}
+
+/**
+ * @brief the callback is invoked when the end of stream happens on the bus.
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+static void busMsgEosCallback(GstBus* bus, GstMessage* msg, gpointer* udata)
+{
+    PSampleConfiguration pSampleConfiguration = (PSampleConfiguration) udata;
+    gstreamerCloseRtspsrc(pSampleConfiguration);
+    return;
+}
+
+/**
+ * @brief the initialization of rtspsrc.
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+STATUS gstreamerRtspsrcInit(PSampleConfiguration pSampleConfiguration, GstElement* pipeline, BOOL enableProbe)
+{
+    PRtspCameraConfiguration pRtspCameraConfiguration = NULL;
+    STATUS retStatus = STATUS_SUCCESS;
+    GstElement* rtspSource = NULL;
+    BOOL locked = FALSE;
+
+    MUTEX_LOCK(pSampleConfiguration->codecConfLock);
+    locked = TRUE;
+    rtspSource = gst_element_factory_make("rtspsrc", "rtspSource");
+    CHK(pipeline != NULL && rtspSource != NULL, STATUS_NULL_ARG);
+    // configure rtspsrc
+    pRtspCameraConfiguration = &pSampleConfiguration->rtspCameraConfiguration;
+    DLOGD("RTSP URL:%s", pRtspCameraConfiguration->uri);
+    g_object_set(G_OBJECT(rtspSource), "location", pRtspCameraConfiguration->uri, "short-header", TRUE, NULL);
+    g_object_set(G_OBJECT(rtspSource), "ntp-sync", TRUE, NULL);
+
+    if (pRtspCameraConfiguration->username[0] != '\0' && pRtspCameraConfiguration->password[0] != '\0') {
+        g_object_set(G_OBJECT(rtspSource), "user-id", pRtspCameraConfiguration->username, NULL);
+        g_object_set(G_OBJECT(rtspSource), "user-pw", pRtspCameraConfiguration->password, NULL);
+    }
+
+    // setup the callbacks.
+    // g_signal_connect(rtspSource, "pad-added", G_CALLBACK(pad_added_cb), tee);
+    if (enableProbe == FALSE) {
+        DLOGD("initializing rtspsrc");
+
+        g_signal_connect(G_OBJECT(rtspSource), "pad-added", G_CALLBACK(rtspsrcOnPadAdded), pSampleConfiguration);
+        g_signal_connect(G_OBJECT(rtspSource), "pad-removed", G_CALLBACK(rtspsrcOnPadRemoved), pSampleConfiguration);
+    } else {
+        DLOGD("probing rtspsrc");
+        // g_signal_connect(G_OBJECT(rtspSource), "on-sdp", G_CALLBACK(rtspsrcOnSdpProbe), pipeline);
+        g_signal_connect(G_OBJECT(rtspSource), "pad-added", G_CALLBACK(rtspsrcOnPadAddedProbe), pSampleConfiguration);
+        g_signal_connect(G_OBJECT(rtspSource), "no-more-pads", G_CALLBACK(rtspsrcOnNoMorePadsProbe), pSampleConfiguration);
+    }
+    gst_bin_add_many(GST_BIN(pipeline), rtspSource, NULL);
+    if (locked) {
+        MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    }
+    return retStatus;
+
+CleanUp:
+
+    gst_object_unref(pipeline);
+    if (locked) {
+        MUTEX_UNLOCK(pSampleConfiguration->codecConfLock);
+    }
+    return retStatus;
+}
+
+PVOID sendGstreamerProbe(PVOID args)
+{
+    STATUS retStatus = STATUS_SUCCESS;
+    PSampleConfiguration pSampleConfiguration = (PSampleConfiguration) args;
+    PCodecConfiguration pGstConfiguration = &pSampleConfiguration->codecConfiguration;
+    GstElement* pipeline = NULL;
+    GstBus* bus = NULL;
+    GstStateChangeReturn gstRetStatus;
+
+    DLOGI("Streaming from rtsp source");
+    CHK(pSampleConfiguration != NULL, STATUS_NULL_ARG);
+    CHK((pipeline = gst_pipeline_new("kinesis-rtsp-probe")) != NULL, STATUS_NULL_ARG);
+    pGstConfiguration->pipeline = pipeline;
+
+    CHK(gstreamerRtspsrcInit(pSampleConfiguration, pipeline, TRUE) == STATUS_SUCCESS, STATUS_NULL_ARG);
+
+    /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */
+    CHK((bus = gst_element_get_bus(pipeline)) != NULL, STATUS_NULL_ARG);
+    gst_bus_add_signal_watch(bus);
+    g_signal_connect(G_OBJECT(bus), "message::error", G_CALLBACK(busMsgErrorCallback), pSampleConfiguration);
+    g_signal_connect(G_OBJECT(bus), "message::eos", G_CALLBACK(busMsgEosCallback), NULL);
+
+    /* start streaming */
+    CHK(gst_element_set_state(pipeline, GST_STATE_PLAYING) != GST_STATE_CHANGE_FAILURE, STATUS_NULL_ARG);
+
+    pGstConfiguration->mainLoop = g_main_loop_new(NULL, FALSE);
+    // start running the main loop, and it is blocking call.
+    g_main_loop_run(pGstConfiguration->mainLoop);
+
+CleanUp:
+
+    /* free resources */
+    DLOGD("Release the Gstreamer resources.");
+    gst_bus_remove_signal_watch(bus);
+    gst_element_set_state(pipeline, GST_STATE_NULL);
+    gst_object_unref(bus);
+    gst_object_unref(pipeline);
+    pGstConfiguration->pipeline = NULL;
+    g_main_loop_unref(pGstConfiguration->mainLoop);
+    pGstConfiguration->mainLoop = NULL;
+
+    return (PVOID) (ULONG_PTR) retStatus;
+}
+
+/**
+ * @brief the handler of video and audio.
+ *          example: "rtspsrc location=%s name=d"
+ *             " d. ! queue ! rtph264depay ! h264parse ! video/x-h264,stream-format=byte-stream,alignment=au,profile=baseline ! appsink sync=TRUE
+ * emit-signals=TRUE name=appsink-video" " d. ! queue ! rtppcmudepay ! mulawdec ! audioconvert ! audioresample ! opusenc !
+ * audio/x-opus,rate=48000,channels=2 ! appsink sync=TRUE emit-signals=TRUE name=appsink-audio"
+ *
+ * @param[in]
+ *
+ * @return STATUS code of the execution. STATUS_SUCCESS on success
+ */
+PVOID sendGstreamerAudioVideo(PVOID args)
+{
+    STATUS retStatus = STATUS_SUCCESS;
+    PSampleConfiguration pSampleConfiguration = (PSampleConfiguration) args;
+    PCodecConfiguration pGstConfiguration = &pSampleConfiguration->codecConfiguration;
+    /* init GStreamer */
+    GstElement* pipeline = NULL;
+    GstBus* bus = NULL;
+    GstStateChangeReturn gstRetStatus;
+    UINT32 i;
+
+    CHK(pSampleConfiguration != NULL, STATUS_NULL_ARG);
+
+    DLOGI("Streaming from rtsp source");
+    CHK((pipeline = gst_pipeline_new("kinesis-rtsp-pipeline")) != NULL, STATUS_NULL_ARG);
+    pGstConfiguration->pipeline = pipeline;
+
+    CHK(gstreamerRtspsrcInit(pSampleConfiguration, pipeline, FALSE) == STATUS_SUCCESS, STATUS_NULL_ARG);
+
+    /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */
+    CHK((bus = gst_element_get_bus(pipeline)) != NULL, STATUS_NULL_ARG);
+    gst_bus_add_signal_watch(bus);
+    g_signal_connect(G_OBJECT(bus), "message::error", G_CALLBACK(busMsgErrorCallback), pSampleConfiguration);
+    g_signal_connect(G_OBJECT(bus), "message::eos", G_CALLBACK(busMsgEosCallback), pSampleConfiguration);
+
+    /* start streaming */
+    CHK(gst_element_set_state(pipeline, GST_STATE_PLAYING) != GST_STATE_CHANGE_FAILURE, STATUS_NULL_ARG);
+
+    pGstConfiguration->mainLoop = g_main_loop_new(NULL, FALSE);
+    // start running the main loop, and it is blocking call.
+    g_main_loop_run(pGstConfiguration->mainLoop);
+
+CleanUp:
+    // close all the streaming session.
+    MUTEX_LOCK(pSampleConfiguration->sampleConfigurationObjLock);
+    for (i = 0; i < pSampleConfiguration->streamingSessionCount; ++i) {
+        DLOGD("terminate the streaming session(%d)", i);
+        ATOMIC_STORE_BOOL(&pSampleConfiguration->sampleStreamingSessionList[i]->terminateFlag, TRUE);
+    }
+    MUTEX_UNLOCK(pSampleConfiguration->sampleConfigurationObjLock);
+    CVAR_BROADCAST(pSampleConfiguration->cvar);
+    /* free resources */
+    DLOGD("Release the Gstreamer resources.");
+    gst_bus_remove_signal_watch(bus);
+    gst_element_set_state(pipeline, GST_STATE_NULL);
+    gst_object_unref(bus);
+    gst_object_unref(pipeline);
+    pGstConfiguration->pipeline = NULL;
+    g_main_loop_unref(pGstConfiguration->mainLoop);
+    pGstConfiguration->mainLoop = NULL;
+
+    return (PVOID) (ULONG_PTR) retStatus;
+}
+
+VOID createStreamingSesstionPreHookFunc(PSampleConfiguration pSampleConfiguration, PSampleStreamingSession pSampleStreamingSession)
+{
+    if (!ATOMIC_LOAD_BOOL(&pSampleConfiguration->codecConfigLatched)) {
+        sendGstreamerProbe(pSampleConfiguration);
+    }
+}
+
+VOID freeStreamingSesstionPostHookFunc(PSampleConfiguration pSampleConfiguration, PSampleStreamingSession pSampleStreamingSession)
+{
+    if (pSampleConfiguration->streamingSessionCount == 0) {
+        ATOMIC_STORE_BOOL(&pSampleConfiguration->terminateCodecFlag, TRUE);
+    }
+}
+
+INT32 main(INT32 argc, CHAR* argv[])
+{
+    STATUS retStatus = STATUS_SUCCESS;
+    PSampleConfiguration pSampleConfiguration = NULL;
+    PCHAR pRtspChannel;
+
+    SET_INSTRUMENTED_ALLOCATORS();
+
+    signal(SIGINT, sigintHandler);
+
+    // do trickle-ice by default
+    printf("[KVS GStreamer Master] Using trickleICE by default\n");
+    CHK_ERR((pRtspChannel = getenv(RTSP_CHANNEL)) != NULL, STATUS_INVALID_OPERATION, "RTSP_CHANNEL must be set");
+
+    retStatus = createSampleConfiguration(pRtspChannel, SIGNALING_CHANNEL_ROLE_TYPE_MASTER, TRUE, TRUE, &pSampleConfiguration);
+    if (retStatus != STATUS_SUCCESS) {
+        printf("[KVS GStreamer Master] createSampleConfiguration(): operation returned status code: 0x%08x \n", retStatus);
+        goto CleanUp;
+    }
+
+    printf("[KVS GStreamer Master] Created signaling channel %s\n", pRtspChannel);
+
+    if (pSampleConfiguration->enableFileLogging) {
+        retStatus =
+            createFileLogger(FILE_LOGGING_BUFFER_SIZE, MAX_NUMBER_OF_LOG_FILES, (PCHAR) FILE_LOGGER_LOG_FILE_DIRECTORY_PATH, TRUE, TRUE, NULL);
+        if (retStatus != STATUS_SUCCESS) {
+            printf("[KVS Master] createFileLogger(): operation returned status code: 0x%08x \n", retStatus);
+            pSampleConfiguration->enableFileLogging = FALSE;
+        }
+    }
+
+    pSampleConfiguration->videoSource = sendGstreamerAudioVideo;
+    pSampleConfiguration->mediaType = SAMPLE_STREAMING_AUDIO_VIDEO;
+    pSampleConfiguration->onDataChannel = onDataChannel;
+    pSampleConfiguration->customData = (UINT64) pSampleConfiguration;
+    pSampleConfiguration->useTestSrc = FALSE;
+    pSampleConfiguration->createStreamingSessionPreHook = createStreamingSesstionPreHookFunc;
+    pSampleConfiguration->freeStreamingSessionPostHook = freeStreamingSesstionPostHookFunc;
+
+    /* Initialize GStreamer */
+    gst_init(NULL, NULL);
+    sendGstreamerProbe(pSampleConfiguration);
+    printf("[KVS Gstreamer Master] Finished initializing GStreamer\n");
+
+    // Initalize KVS WebRTC. This must be done before anything else, and must only be done once.
+    retStatus = initKvsWebRtc();
+    if (retStatus != STATUS_SUCCESS) {
+        printf("[KVS GStreamer Master] initKvsWebRtc(): operation returned status code: 0x%08x \n", retStatus);
+        goto CleanUp;
+    }
+    printf("[KVS GStreamer Master] KVS WebRTC initialization completed successfully\n");
+
+    pSampleConfiguration->signalingClientCallbacks.messageReceivedFn = signalingMessageReceived;
+
+    strcpy(pSampleConfiguration->clientInfo.clientId, SAMPLE_MASTER_CLIENT_ID);
+
+    retStatus = createSignalingClientSync(&pSampleConfiguration->clientInfo, &pSampleConfiguration->channelInfo,
+                                          &pSampleConfiguration->signalingClientCallbacks, pSampleConfiguration->pCredentialProvider,
+                                          &pSampleConfiguration->signalingClientHandle);
+    if (retStatus != STATUS_SUCCESS) {
+        printf("[KVS GStreamer Master] createSignalingClientSync(): operation returned status code: 0x%08x \n", retStatus);
+    }
+    printf("[KVS GStreamer Master] Signaling client created successfully\n");
+
+    // Enable the processing of the messages
+    retStatus = signalingClientConnectSync(pSampleConfiguration->signalingClientHandle);
+    if (retStatus != STATUS_SUCCESS) {
+        printf("[KVS GStreamer Master] signalingClientConnectSync(): operation returned status code: 0x%08x \n", retStatus);
+        goto CleanUp;
+    }
+
+    printf("[KVS GStreamer Master] Signaling client connection to socket established\n");
+    printf("[KVS Gstreamer Master] Beginning streaming...check the stream over channel %s\n", pRtspChannel);
+
+    gSampleConfiguration = pSampleConfiguration;
+
+    // Checking for termination
+    retStatus = sessionCleanupWait(pSampleConfiguration);
+    if (retStatus != STATUS_SUCCESS) {
+        printf("[KVS GStreamer Master] sessionCleanupWait(): operation returned status code: 0x%08x \n", retStatus);
+        goto CleanUp;
+    }
+
+    printf("[KVS GStreamer Master] Streaming session terminated\n");
+
+CleanUp:
+
+    if (retStatus != STATUS_SUCCESS) {
+        printf("[KVS GStreamer Master] Terminated with status code 0x%08x", retStatus);
+    }
+
+    printf("[KVS GStreamer Master] Cleaning up....\n");
+
+    if (pSampleConfiguration != NULL) {
+        // Kick of the termination sequence
+        ATOMIC_STORE_BOOL(&pSampleConfiguration->appTerminateFlag, TRUE);
+
+        if (pSampleConfiguration->mediaSenderTid != INVALID_TID_VALUE) {
+            THREAD_JOIN(pSampleConfiguration->mediaSenderTid, NULL);
+        }
+
+        if (pSampleConfiguration->enableFileLogging) {
+            freeFileLogger();
+        }
+        retStatus = freeSignalingClient(&pSampleConfiguration->signalingClientHandle);
+        if (retStatus != STATUS_SUCCESS) {
+            printf("[KVS GStreamer Master] freeSignalingClient(): operation returned status code: 0x%08x \n", retStatus);
+        }
+
+        retStatus = freeSampleConfiguration(&pSampleConfiguration);
+        if (retStatus != STATUS_SUCCESS) {
+            printf("[KVS GStreamer Master] freeSampleConfiguration(): operation returned status code: 0x%08x \n", retStatus);
+        }
+    }
+    printf("[KVS Gstreamer Master] Cleanup done\n");
+
+    RESET_INSTRUMENTED_ALLOCATORS();
+    // https://www.gnu.org/software/libc/manual/html_node/Exit-Status.html
+    // We can only return with 0 - 127. Some platforms treat exit code >= 128
+    // to be a success code, which might give an unintended behaviour.
+    // Some platforms also treat 1 or 0 differently, so it's better to use
+    // EXIT_FAILURE and EXIT_SUCCESS macros for portability.
+    return STATUS_FAILED(retStatus) ? EXIT_FAILURE : EXIT_SUCCESS;
+}
diff --git a/samples/kvsWebRTCClientMasterGstreamerSample.c b/samples/kvsWebRTCClientMasterGstreamerSample.c
index e82556cdf..6663bcba5 100644
--- a/samples/kvsWebRTCClientMasterGstreamerSample.c
+++ b/samples/kvsWebRTCClientMasterGstreamerSample.c
@@ -345,12 +345,7 @@ INT32 main(INT32 argc, CHAR* argv[])
 
     // do trickle-ice by default
     printf("[KVS GStreamer Master] Using trickleICE by default\n");
-
-#ifdef IOT_CORE_ENABLE_CREDENTIALS
-    CHK_ERR((pChannelName = getenv(IOT_CORE_THING_NAME)) != NULL, STATUS_INVALID_OPERATION, "AWS_IOT_CORE_THING_NAME must be set");
-#else
     pChannelName = argc > 1 ? argv[1] : SAMPLE_CHANNEL_NAME;
-#endif
 
     retStatus = createSampleConfiguration(pChannelName, SIGNALING_CHANNEL_ROLE_TYPE_MASTER, TRUE, TRUE, &pSampleConfiguration);
     if (retStatus != STATUS_SUCCESS) {
diff --git a/samples/kvsWebRTCClientViewer.c b/samples/kvsWebRTCClientViewer.c
index 497d1783e..b6fae5c22 100644
--- a/samples/kvsWebRTCClientViewer.c
+++ b/samples/kvsWebRTCClientViewer.c
@@ -21,12 +21,7 @@ INT32 main(INT32 argc, CHAR* argv[])
 
     // do trickle-ice by default
     printf("[KVS Master] Using trickleICE by default\n");
-
-#ifdef IOT_CORE_ENABLE_CREDENTIALS
-        CHK_ERR((pChannelName = getenv(IOT_CORE_THING_NAME)) != NULL, STATUS_INVALID_OPERATION, "AWS_IOT_CORE_THING_NAME must be set");
-#else
-        pChannelName = argc > 1 ? argv[1] : SAMPLE_CHANNEL_NAME;
-#endif
+    pChannelName = argc > 1 ? argv[1] : SAMPLE_CHANNEL_NAME;
 
     retStatus = createSampleConfiguration(pChannelName, SIGNALING_CHANNEL_ROLE_TYPE_VIEWER, TRUE, TRUE, &pSampleConfiguration);
     if (retStatus != STATUS_SUCCESS) {
diff --git a/scripts/generate-iot-credential.sh b/scripts/generate-iot-credential.sh
index ae3b3c720..c09469e0b 100755
--- a/scripts/generate-iot-credential.sh
+++ b/scripts/generate-iot-credential.sh
@@ -8,15 +8,21 @@ iotPolicyName="webrtc_iot_policy"
 kvsPolicyName="webrtc_policy"
 iotRoleName="webrtc_iot_role"
 iotRoleAlias="webrtc_iot_role_alias"
+cacert="cacert.pem"
 iotCert="webrtc_iot_certifcate.pem"
 iotPublicKey="webrtc_iot_public.key"
 iotPrivateKey="webrtc_iot_private.key"
+tmpPath="iot-tmp"
+certPath="iot-cert"
+
+mkdir -p $tmpPath
+mkdir -p $certPath
 
 # Step 1: Create an IoT Thing Type and an IoT Thing
 # The following example command creates a thing type $thingTypeName
-aws --profile default  iot create-thing-type --thing-type-name $thingTypeName > iot-thing-type.json
+aws --profile default  iot create-thing-type --thing-type-name $thingTypeName > $tmpPath/iot-thing-type.json
 # And this example command creates the $thingName thing of the $thingTypeName thing type:
-aws --profile default  iot create-thing --thing-name $thingName --thing-type-name $thingTypeName > iot-thing.json
+aws --profile default  iot create-thing --thing-name $thingName --thing-type-name $thingTypeName > $tmpPath/iot-thing.json
 
 # Step 2: Create an IAM Role to be Assumed by IoT
 # You can use the following trust policy JSON for the iam-policy-document.json:
@@ -31,9 +37,9 @@ echo '{
      "Action":"sts:AssumeRole"
     }
    ]
-}' > iam-policy-document.json
+}' > $tmpPath/iam-policy-document.json
 # Create an IAM role.
-aws --profile default  iam create-role --role-name $iotRoleName --assume-role-policy-document 'file://iam-policy-document.json' > iam-role.json
+aws --profile default  iam create-role --role-name $iotRoleName --assume-role-policy-document file://$tmpPath/iam-policy-document.json > $tmpPath/iam-role.json
 
 # You can use the following IAM policy JSON for the iam-permission-document.json:
 echo '{
@@ -50,17 +56,17 @@ echo '{
                 "kinesisvideo:ConnectAsMaster",
                 "kinesisvideo:ConnectAsViewer"
             ],
-            "Resource": "arn:aws:kinesisvideo:*:*:channel/${credentials-iot:ThingName}/*"
+            "Resource": "arn:aws:kinesisvideo:*:*:channel/*/*"
         }
     ]
-}' > iam-permission-document.json
+}' > $tmpPath/iam-permission-document.json
 # Next, you must attach a permissions policy to the IAM role you created above. 
-aws --profile default iam put-role-policy --role-name $iotRoleName --policy-name $kvsPolicyName --policy-document 'file://iam-permission-document.json' 
+aws --profile default iam put-role-policy --role-name $iotRoleName --policy-name $kvsPolicyName --policy-document file://$tmpPath/iam-permission-document.json > $tmpPath/iot-policy.json
 # Next, create a Role Alias for your IAM Role
-aws --profile default  iot create-role-alias --role-alias $iotRoleAlias --role-arn $(jq --raw-output '.Role.Arn' iam-role.json) --credential-duration-seconds 3600 > iot-role-alias.json
+aws --profile default  iot create-role-alias --role-alias $iotRoleAlias --role-arn $(jq --raw-output '.Role.Arn' $tmpPath/iam-role.json) --credential-duration-seconds 3600 > $tmpPath/iot-role-alias.json
 
 # You can use the following command to create the iot-policy-document.json document JSON:
-cat > iot-policy-document.json <<EOF
+cat > $tmpPath/iot-policy-document.json <<EOF
 {
    "Version":"2012-10-17",
    "Statement":[
@@ -69,37 +75,38 @@ cat > iot-policy-document.json <<EOF
 	 "Action":[
 	    "iot:Connect"
 	 ],
-	 "Resource":"$(jq --raw-output '.roleAliasArn' iot-role-alias.json)"
+	 "Resource":"$(jq --raw-output '.roleAliasArn' $tmpPath/iot-role-alias.json)"
  },
       {
 	 "Effect":"Allow",
 	 "Action":[
 	    "iot:AssumeRoleWithCertificate"
 	 ],
-	 "Resource":"$(jq --raw-output '.roleAliasArn' iot-role-alias.json)"
+	 "Resource":"$(jq --raw-output '.roleAliasArn' $tmpPath/iot-role-alias.json)"
  }
    ]
 }
 EOF
 # Now you can create the policy that will enable IoT to assume role with the certificate (once it is attached) using the role alias.
-aws --profile default iot create-policy --policy-name $iotPolicyName --policy-document 'file://iot-policy-document.json' 
+aws --profile default iot create-policy --policy-name $iotPolicyName --policy-document file://$tmpPath/iot-policy-document.json
 
 # Step 3: Create and Configure the X.509 Certificate
 # Create the certificate to which you must attach the policy for IoT that you created above.
-aws --profile default  iot create-keys-and-certificate --set-as-active --certificate-pem-outfile $iotCert --public-key-outfile $iotPublicKey --private-key-outfile $iotPrivateKey > certificate
+aws --profile default  iot create-keys-and-certificate --set-as-active --certificate-pem-outfile $certPath/$iotCert --public-key-outfile $certPath/$iotPublicKey --private-key-outfile $certPath/$iotPrivateKey > $tmpPath/certificate
 # Attach the policy for IoT (KvsCameraIoTPolicy created above) to this certificate.
-aws --profile default  iot attach-policy --policy-name $iotPolicyName --target $(jq --raw-output '.certificateArn' certificate)
+aws --profile default  iot attach-policy --policy-name $iotPolicyName --target $(jq --raw-output '.certificateArn' $tmpPath/certificate)
 # Attach your IoT thing (kvs_example_camera_stream) to the certificate you just created:
-aws --profile default  iot attach-thing-principal --thing-name $thingName --principal $(jq --raw-output '.certificateArn' certificate)
+aws --profile default  iot attach-thing-principal --thing-name $thingName --principal $(jq --raw-output '.certificateArn' $tmpPath/certificate)
 # In order to authorize requests through the IoT credentials provider, you need the IoT credentials endpoint which is unique to your AWS account ID. You can use the following command to get the IoT credentials endpoint.
-aws --profile default  iot describe-endpoint --endpoint-type iot:CredentialProvider --output text > iot-credential-provider.txt
+aws --profile default  iot describe-endpoint --endpoint-type iot:CredentialProvider --output text > $tmpPath/iot-credential-provider.txt
 # In addition to the X.509 cerficiate created above, you must also have a CA certificate to establish trust with the back-end service through TLS. You can get the CA certificate using the following command:
-curl --silent 'https://www.amazontrust.com/repository/SFSRootCAG2.pem' --output cacert.pem
+curl --silent 'https://www.amazontrust.com/repository/SFSRootCAG2.pem' --output $certPath/$cacert
 
 
-export AWS_IOT_CORE_CREDENTIAL_ENDPOINT=$(cat iot-credential-provider.txt)
-export AWS_IOT_CORE_CERT=$(pwd)"/"$iotCert
-export AWS_IOT_CORE_PRIVATE_KEY=$(pwd)"/"$iotPrivateKey
+export AWS_IOT_CORE_CREDENTIAL_ENDPOINT=$(cat $tmpPath/iot-credential-provider.txt)
+export AWS_KVS_CACERT_PATH=$(pwd)"/"$certPath"/"$cacert
+export AWS_IOT_CORE_CERT=$(pwd)"/"$certPath"/"$iotCert
+export AWS_IOT_CORE_PRIVATE_KEY=$(pwd)"/"$certPath"/"$iotPrivateKey
 export AWS_IOT_CORE_ROLE_ALIAS=$iotRoleAlias
 export AWS_IOT_CORE_THING_NAME=$thingName
         
diff --git a/src/source/Signaling/LwsApiCalls.c b/src/source/Signaling/LwsApiCalls.c
index 0298b5083..19c715d67 100644
--- a/src/source/Signaling/LwsApiCalls.c
+++ b/src/source/Signaling/LwsApiCalls.c
@@ -663,10 +663,11 @@ STATUS describeChannelLws(PSignalingClient pSignalingClient, UINT64 time)
     SNPRINTF(paramsJson, ARRAY_SIZE(paramsJson), DESCRIBE_CHANNEL_PARAM_JSON_TEMPLATE, pSignalingClient->pChannelInfo->pChannelName);
 
     // Create the request info with the body
-    CHK_STATUS(createRequestInfo(url, paramsJson, pSignalingClient->pChannelInfo->pRegion, pSignalingClient->pChannelInfo->pCertPath, NULL, NULL,
-                                 SSL_CERTIFICATE_TYPE_NOT_SPECIFIED, pSignalingClient->pChannelInfo->pUserAgent,
-                                 SIGNALING_SERVICE_API_CALL_CONNECTION_TIMEOUT, SIGNALING_SERVICE_API_CALL_COMPLETION_TIMEOUT,
-                                 DEFAULT_LOW_SPEED_LIMIT, DEFAULT_LOW_SPEED_TIME_LIMIT, pSignalingClient->pAwsCredentials, &pRequestInfo));
+    CHK_STATUS(createRequestInfo(url, paramsJson, DEFAULT_SSL_PORT_NUMBER, pSignalingClient->pChannelInfo->pRegion,
+                                 pSignalingClient->pChannelInfo->pCertPath, NULL, NULL, SSL_CERTIFICATE_TYPE_NOT_SPECIFIED,
+                                 pSignalingClient->pChannelInfo->pUserAgent, SIGNALING_SERVICE_API_CALL_CONNECTION_TIMEOUT,
+                                 SIGNALING_SERVICE_API_CALL_COMPLETION_TIMEOUT, DEFAULT_LOW_SPEED_LIMIT, DEFAULT_LOW_SPEED_TIME_LIMIT,
+                                 pSignalingClient->pAwsCredentials, &pRequestInfo));
 
     CHK_STATUS(createLwsCallInfo(pSignalingClient, pRequestInfo, PROTOCOL_INDEX_HTTPS, &pLwsCallInfo));
 
@@ -808,10 +809,11 @@ STATUS createChannelLws(PSignalingClient pSignalingClient, UINT64 time)
              pSignalingClient->pChannelInfo->messageTtl / HUNDREDS_OF_NANOS_IN_A_SECOND, tagsJson);
 
     // Create the request info with the body
-    CHK_STATUS(createRequestInfo(url, paramsJson, pSignalingClient->pChannelInfo->pRegion, pSignalingClient->pChannelInfo->pCertPath, NULL, NULL,
-                                 SSL_CERTIFICATE_TYPE_NOT_SPECIFIED, pSignalingClient->pChannelInfo->pUserAgent,
-                                 SIGNALING_SERVICE_API_CALL_CONNECTION_TIMEOUT, SIGNALING_SERVICE_API_CALL_COMPLETION_TIMEOUT,
-                                 DEFAULT_LOW_SPEED_LIMIT, DEFAULT_LOW_SPEED_TIME_LIMIT, pSignalingClient->pAwsCredentials, &pRequestInfo));
+    CHK_STATUS(createRequestInfo(url, paramsJson, DEFAULT_SSL_PORT_NUMBER, pSignalingClient->pChannelInfo->pRegion,
+                                 pSignalingClient->pChannelInfo->pCertPath, NULL, NULL, SSL_CERTIFICATE_TYPE_NOT_SPECIFIED,
+                                 pSignalingClient->pChannelInfo->pUserAgent, SIGNALING_SERVICE_API_CALL_CONNECTION_TIMEOUT,
+                                 SIGNALING_SERVICE_API_CALL_COMPLETION_TIMEOUT, DEFAULT_LOW_SPEED_LIMIT, DEFAULT_LOW_SPEED_TIME_LIMIT,
+                                 pSignalingClient->pAwsCredentials, &pRequestInfo));
 
     CHK_STATUS(createLwsCallInfo(pSignalingClient, pRequestInfo, PROTOCOL_INDEX_HTTPS, &pLwsCallInfo));
 
@@ -882,10 +884,11 @@ STATUS getChannelEndpointLws(PSignalingClient pSignalingClient, UINT64 time)
              SIGNALING_CHANNEL_PROTOCOL, getStringFromChannelRoleType(pSignalingClient->pChannelInfo->channelRoleType));
 
     // Create the request info with the body
-    CHK_STATUS(createRequestInfo(url, paramsJson, pSignalingClient->pChannelInfo->pRegion, pSignalingClient->pChannelInfo->pCertPath, NULL, NULL,
-                                 SSL_CERTIFICATE_TYPE_NOT_SPECIFIED, pSignalingClient->pChannelInfo->pUserAgent,
-                                 SIGNALING_SERVICE_API_CALL_CONNECTION_TIMEOUT, SIGNALING_SERVICE_API_CALL_COMPLETION_TIMEOUT,
-                                 DEFAULT_LOW_SPEED_LIMIT, DEFAULT_LOW_SPEED_TIME_LIMIT, pSignalingClient->pAwsCredentials, &pRequestInfo));
+    CHK_STATUS(createRequestInfo(url, paramsJson, DEFAULT_SSL_PORT_NUMBER, pSignalingClient->pChannelInfo->pRegion,
+                                 pSignalingClient->pChannelInfo->pCertPath, NULL, NULL, SSL_CERTIFICATE_TYPE_NOT_SPECIFIED,
+                                 pSignalingClient->pChannelInfo->pUserAgent, SIGNALING_SERVICE_API_CALL_CONNECTION_TIMEOUT,
+                                 SIGNALING_SERVICE_API_CALL_COMPLETION_TIMEOUT, DEFAULT_LOW_SPEED_LIMIT, DEFAULT_LOW_SPEED_TIME_LIMIT,
+                                 pSignalingClient->pAwsCredentials, &pRequestInfo));
 
     CHK_STATUS(createLwsCallInfo(pSignalingClient, pRequestInfo, PROTOCOL_INDEX_HTTPS, &pLwsCallInfo));
 
@@ -1013,10 +1016,11 @@ STATUS getIceConfigLws(PSignalingClient pSignalingClient, UINT64 time)
              pSignalingClient->clientInfo.signalingClientInfo.clientId);
 
     // Create the request info with the body
-    CHK_STATUS(createRequestInfo(url, paramsJson, pSignalingClient->pChannelInfo->pRegion, pSignalingClient->pChannelInfo->pCertPath, NULL, NULL,
-                                 SSL_CERTIFICATE_TYPE_NOT_SPECIFIED, pSignalingClient->pChannelInfo->pUserAgent,
-                                 SIGNALING_SERVICE_API_CALL_CONNECTION_TIMEOUT, SIGNALING_SERVICE_API_CALL_COMPLETION_TIMEOUT,
-                                 DEFAULT_LOW_SPEED_LIMIT, DEFAULT_LOW_SPEED_TIME_LIMIT, pSignalingClient->pAwsCredentials, &pRequestInfo));
+    CHK_STATUS(createRequestInfo(url, paramsJson, DEFAULT_SSL_PORT_NUMBER, pSignalingClient->pChannelInfo->pRegion,
+                                 pSignalingClient->pChannelInfo->pCertPath, NULL, NULL, SSL_CERTIFICATE_TYPE_NOT_SPECIFIED,
+                                 pSignalingClient->pChannelInfo->pUserAgent, SIGNALING_SERVICE_API_CALL_CONNECTION_TIMEOUT,
+                                 SIGNALING_SERVICE_API_CALL_COMPLETION_TIMEOUT, DEFAULT_LOW_SPEED_LIMIT, DEFAULT_LOW_SPEED_TIME_LIMIT,
+                                 pSignalingClient->pAwsCredentials, &pRequestInfo));
 
     CHK_STATUS(createLwsCallInfo(pSignalingClient, pRequestInfo, PROTOCOL_INDEX_HTTPS, &pLwsCallInfo));
 
@@ -1130,10 +1134,11 @@ STATUS deleteChannelLws(PSignalingClient pSignalingClient, UINT64 time)
              pSignalingClient->channelDescription.updateVersion);
 
     // Create the request info with the body
-    CHK_STATUS(createRequestInfo(url, paramsJson, pSignalingClient->pChannelInfo->pRegion, pSignalingClient->pChannelInfo->pCertPath, NULL, NULL,
-                                 SSL_CERTIFICATE_TYPE_NOT_SPECIFIED, pSignalingClient->pChannelInfo->pUserAgent,
-                                 SIGNALING_SERVICE_API_CALL_CONNECTION_TIMEOUT, SIGNALING_SERVICE_API_CALL_COMPLETION_TIMEOUT,
-                                 DEFAULT_LOW_SPEED_LIMIT, DEFAULT_LOW_SPEED_TIME_LIMIT, pSignalingClient->pAwsCredentials, &pRequestInfo));
+    CHK_STATUS(createRequestInfo(url, paramsJson, DEFAULT_SSL_PORT_NUMBER, pSignalingClient->pChannelInfo->pRegion,
+                                 pSignalingClient->pChannelInfo->pCertPath, NULL, NULL, SSL_CERTIFICATE_TYPE_NOT_SPECIFIED,
+                                 pSignalingClient->pChannelInfo->pUserAgent, SIGNALING_SERVICE_API_CALL_CONNECTION_TIMEOUT,
+                                 SIGNALING_SERVICE_API_CALL_COMPLETION_TIMEOUT, DEFAULT_LOW_SPEED_LIMIT, DEFAULT_LOW_SPEED_TIME_LIMIT,
+                                 pSignalingClient->pAwsCredentials, &pRequestInfo));
 
     CHK_STATUS(createLwsCallInfo(pSignalingClient, pRequestInfo, PROTOCOL_INDEX_HTTPS, &pLwsCallInfo));
 
@@ -1239,10 +1244,11 @@ STATUS connectSignalingChannelLws(PSignalingClient pSignalingClient, UINT64 time
     }
 
     // Create the request info with the body
-    CHK_STATUS(createRequestInfo(url, NULL, pSignalingClient->pChannelInfo->pRegion, pSignalingClient->pChannelInfo->pCertPath, NULL, NULL,
-                                 SSL_CERTIFICATE_TYPE_NOT_SPECIFIED, pSignalingClient->pChannelInfo->pUserAgent,
-                                 SIGNALING_SERVICE_API_CALL_CONNECTION_TIMEOUT, SIGNALING_SERVICE_API_CALL_COMPLETION_TIMEOUT,
-                                 DEFAULT_LOW_SPEED_LIMIT, DEFAULT_LOW_SPEED_TIME_LIMIT, pSignalingClient->pAwsCredentials, &pRequestInfo));
+    CHK_STATUS(createRequestInfo(url, NULL, DEFAULT_SSL_PORT_NUMBER, pSignalingClient->pChannelInfo->pRegion,
+                                 pSignalingClient->pChannelInfo->pCertPath, NULL, NULL, SSL_CERTIFICATE_TYPE_NOT_SPECIFIED,
+                                 pSignalingClient->pChannelInfo->pUserAgent, SIGNALING_SERVICE_API_CALL_CONNECTION_TIMEOUT,
+                                 SIGNALING_SERVICE_API_CALL_COMPLETION_TIMEOUT, DEFAULT_LOW_SPEED_LIMIT, DEFAULT_LOW_SPEED_TIME_LIMIT,
+                                 pSignalingClient->pAwsCredentials, &pRequestInfo));
     // Override the POST with GET
     pRequestInfo->verb = HTTP_REQUEST_VERB_GET;
 
-- 
2.20.1 (Apple Git-117)

